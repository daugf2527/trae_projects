{"version":3,"sources":["../../src/playwright/EthereumWalletMock.ts","../../src/constants.ts","../../src/type/EthereumWalletMockAbstract.ts","../../src/playwright/utils/mockEthereum.ts","../../src/playwright/utils/mockTransaction.ts","../../src/playwright/utils/sendTransaction.ts","../../src/playwright/constants.ts","../../src/playwright/fixtures/ethereumWalletMockFixtures.ts"],"names":["params","require","accounts","accountAddress","networkInfo","networkName","wallet"],"mappings":"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","sourcesContent":["import type { Page } from '@playwright/test'\nimport { mnemonicToAccount, privateKeyToAccount } from 'viem/accounts'\nimport { ACCOUNT_MOCK, BLOCKCHAIN } from '../constants'\nimport { EthereumWalletMockAbstract } from '../type/EthereumWalletMockAbstract'\nimport type { Network } from '../type/Network'\nimport type { WalletMock } from '../type/WalletMock'\nimport { DEFAULT_NETWORK_ID } from './utils'\nimport { mockTransaction, sendTransaction } from './utils'\n\n/**\n * Mock implementation of an Ethereum wallet for testing purposes.\n * Simulates wallet behavior in a controlled environment, allowing for consistent\n * and reproducible tests without relying on actual blockchain interactions.\n *\n * @class\n * @extends {EthereumWalletMockAbstract}\n */\nexport default class EthereumWalletMock extends EthereumWalletMockAbstract {\n  /** The Playwright Page object to interact with. */\n  page: Page\n\n  /**\n   * Creates an instance of EthereumWalletMock.\n   * @param page - The Playwright Page object to interact with.\n   * @param wallet - The type of wallet to mock.\n   */\n  constructor(page: Page, wallet: WalletMock = 'metamask') {\n    super(wallet)\n    this.page = page\n    this.wallet = wallet\n  }\n\n  /**\n   * Imports a wallet using the given seed phrase.\n   * @param seedPhrase - The seed phrase to import.\n   * @returns A promise that resolves when the wallet is imported.\n   */\n  importWallet(seedPhrase: string): Promise<void> {\n    this.seedPhrase = seedPhrase\n\n    return this.page.evaluate(\n      ([blockchain, wallet, accounts]) => {\n        class WalletConnectStub {}\n\n        let connector: WalletConnectStub | undefined\n\n        if (wallet === 'walletconnect') {\n          connector = WalletConnectStub\n        }\n\n        return Web3Mock.mock({\n          blockchain,\n          wallet,\n          accounts: {\n            return: accounts\n          },\n          connector\n        })\n      },\n      [BLOCKCHAIN, this.wallet, [ACCOUNT_MOCK]]\n    )\n  }\n\n  /**\n   * Retrieves all account addresses.\n   * @returns A promise that resolves to an array of account addresses.\n   */\n  async getAllAccounts(): Promise<`0x${string}`[] | undefined> {\n    return this.page.evaluate(() => {\n      return window.ethereum.request({ method: 'eth_requestAccounts' })\n    })\n  }\n\n  /**\n   * Adds a new account based on the initially imported seed phrase.\n   * @returns A promise that resolves when the new account is added.\n   */\n  async addNewAccount(): Promise<void> {\n    const accounts = await this.getAllAccounts()\n\n    const newAccount = mnemonicToAccount(this.seedPhrase || '', {\n      accountIndex: accounts?.length\n    })\n\n    return this.page.evaluate(\n      ([blockchain, wallet, accounts]) => {\n        return Web3Mock.mock({\n          blockchain,\n          wallet,\n          accounts: {\n            return: accounts\n          }\n        })\n      },\n      [BLOCKCHAIN, this.wallet, [newAccount.address, ...(accounts || [])]]\n    )\n  }\n\n  /**\n   * Imports a wallet using the given private key.\n   * @param privateKey - The private key to import.\n   * @returns A promise that resolves when the wallet is imported.\n   */\n  async importWalletFromPrivateKey(privateKey: `0x${string}`): Promise<void> {\n    const newAccount = privateKeyToAccount(privateKey)\n\n    return this.page.evaluate(\n      ([blockchain, wallet, account]) => {\n        return Web3Mock.mock({\n          blockchain,\n          wallet,\n          accounts: {\n            return: account\n          }\n        })\n      },\n      [BLOCKCHAIN, this.wallet, [newAccount.address]]\n    )\n  }\n\n  /**\n   * Switches to the account with the given address.\n   * @param accountAddress - The address of the account to switch to.\n   * @returns A promise that resolves when the account switch is complete.\n   */\n  async switchAccount(accountAddress: string): Promise<void> {\n    return this.page.evaluate(\n      ([blockchain, wallet, accountAddress]) => {\n        return Web3Mock.mock({\n          blockchain,\n          wallet,\n          accounts: {\n            return: [accountAddress]\n          }\n        })\n      },\n      [BLOCKCHAIN, this.wallet, accountAddress]\n    )\n  }\n\n  /**\n   * Adds a new network.\n   * @param network - The network object to use for adding the new network.\n   * @returns A promise that resolves when the network is added.\n   */\n  async addNetwork(network: Network): Promise<void> {\n    const networkInfo = {\n      chainId: network.chainId,\n      chainName: network.name,\n      nativeCurrency: network.nativeCurrency,\n      rpcUrls: [network.rpcUrl],\n      blockExplorerUrls: [network.blockExplorerUrl]\n    }\n\n    return this.page.evaluate(\n      ([blockchain, wallet, networkInfo]) => {\n        return Web3Mock.mock({\n          blockchain,\n          wallet,\n          network: {\n            add: networkInfo\n          }\n        })\n      },\n      [BLOCKCHAIN, this.wallet, networkInfo]\n    )\n  }\n\n  /**\n   * Retrieves the current account address.\n   * @returns A promise that resolves to the current account address.\n   */\n  async getAccountAddress(): Promise<`0x${string}` | undefined> {\n    return (await this.getAllAccounts())?.[0]\n  }\n\n  /**\n   * Switches to the network with the given name.\n   * @param networkName - The name of the network to switch to.\n   * @returns A promise that resolves when the network switch is complete.\n   */\n  async switchNetwork(networkName: string): Promise<void> {\n    return this.page.evaluate(\n      ([blockchain, wallet, networkName, chainId]) => {\n        Web3Mock.mock({\n          blockchain,\n          wallet,\n          network: {\n            switchTo: networkName\n          }\n        })\n\n        window.ethereum.request({\n          method: 'wallet_switchEthereumChain',\n          // Mock do not support custom network IDs\n          params: [{ chainId }]\n        })\n      },\n      [BLOCKCHAIN, this.wallet, networkName, DEFAULT_NETWORK_ID]\n    )\n  }\n\n  /**\n   * Connects wallet to the dapp.\n   * @param wallet - The wallet to connect to the dapp.\n   * @returns A promise that resolves when the wallet is connected to the dapp.\n   */\n  connectToDapp(wallet: WalletMock = 'metamask'): Promise<void> {\n    this.wallet = wallet\n\n    return this.page.evaluate(\n      ([blockchain, accounts, wallet]) => {\n        // Cannot pass custom class as an argument to `page.evaluate`\n        class WalletConnectStub {}\n\n        let connector: WalletConnectStub | undefined\n\n        if (wallet === 'walletconnect') {\n          connector = WalletConnectStub\n        }\n\n        return Web3Mock.mock({\n          blockchain,\n          wallet,\n          accounts: {\n            return: accounts\n          },\n          connector\n        })\n      },\n      [BLOCKCHAIN, [ACCOUNT_MOCK], wallet]\n    )\n  }\n\n  /**\n   * Sends a transaction.\n   * @param to - Recipient address.\n   * @param value - Transaction value in wei.\n   * @returns Promise that resolves to the transaction hash.\n   */\n  async sendTransaction(to: string, value: string): Promise<string> {\n    // Mock the transaction\n    await mockTransaction(this.page, [\n      to,\n      ACCOUNT_MOCK, // from address\n      value\n    ])\n\n    // Send the transaction\n    return this.page.evaluate(sendTransaction, {\n      to,\n      from: ACCOUNT_MOCK,\n      value\n    })\n  }\n}\n","// Wallet\nexport const SEED_PHRASE = 'test test test test test test test test test test test junk'\n\nexport const BLOCKCHAIN = 'ethereum'\n\nexport const ACCOUNT_MOCK = '0xd73b04b0e696b0945283defa3eee453814758f1a'\n\n// Anvil\nexport const ANVIL_CHAIN_ID = 31337\n\nexport const ANVIL_URL_URL = 'http://anvil:5000'\n","import type { Network } from './Network'\nimport type { WalletMock } from './WalletMock'\n\nexport abstract class EthereumWalletMockAbstract {\n  seedPhrase: string | undefined\n  wallet: WalletMock\n\n  protected constructor(wallet: WalletMock = 'metamask') {\n    this.wallet = wallet\n  }\n\n  /**\n   * Imports a wallet using the given seed phrase.\n   *\n   * @param seedPhrase - The seed phrase to import.\n   */\n  abstract importWallet(seedPhrase: string): void\n\n  /**\n   * Retrieves the current account address.\n   */\n  abstract getAllAccounts(): Cypress.Chainable<`0x${string}`[]> | Promise<`0x${string}`[] | undefined>\n\n  /**\n   * Adds a new account. This account is based on the initially imported seed phrase.\n   */\n  abstract addNewAccount(): void\n\n  /**\n   * Imports a wallet using the given private key.\n   *\n   * @param privateKey - The private key to import.\n   */\n  abstract importWalletFromPrivateKey(privateKey: `0x${string}`): void\n\n  /**\n   * Switches to the account with the given name.\n   *\n   * @param accountAddress - The name of the account to switch to.\n   */\n  abstract switchAccount(accountAddress: string): void\n\n  /**\n   * Adds a new network.\n   *\n   * @param network - The network object to use for adding the new network.\n   */\n  abstract addNetwork(network: Network): void\n\n  /**\n   * Retrieves the current account address.\n   */\n  abstract getAccountAddress(): Cypress.Chainable<`0x${string}`> | Promise<`0x${string}` | undefined>\n\n  /**\n   * Switches to the network with the given name.\n   *\n   * @param networkName - The name of the network to switch to.\n   */\n  abstract switchNetwork(networkName: string): void\n\n  /**\n   * Connects wallet to the dapp.\n   *\n   * @param wallet - The wallet to connect to the dapp.\n   */\n  abstract connectToDapp(wallet: WalletMock): void\n}\n","export default function mockEthereum(\n  wallet: 'metamask' | 'coinbase' | 'phantom' | 'walletconnect' | 'walletlink' = 'metamask',\n  accounts: `0x${string}`[] = []\n) {\n  Web3Mock.mock({\n    blockchain: 'ethereum',\n    wallet,\n    accounts: {\n      return: accounts\n    }\n  })\n}\n","import type { Page } from '@playwright/test'\n\n/**\n * Mocks an Ethereum transaction using Web3Mock\n * @param page - Playwright page instance\n * @param params - Array of transaction parameters [to, from, value]\n * @returns Promise that resolves to the Web3Mock mock result\n */\nexport const mockTransaction = async (page: Page, params: [string, string, string]) => {\n  return page.evaluate(\n    ([params]) => {\n      return Web3Mock.mock({\n        blockchain: 'ethereum',\n        transaction: {\n          to: params?.[0],\n          from: params?.[1],\n          value: params?.[2]\n        }\n      })\n    },\n    [params]\n  )\n}\n","interface SendTransactionParams {\n  to: string\n  from: string\n  value: string\n}\n\n/**\n * Sends an Ethereum transaction using Web3Mock\n * @param params - Transaction parameters {to: string, from: string, value: string}\n * @returns Promise that resolves to the transaction hash\n */\nexport const sendTransaction = (params: SendTransactionParams): Promise<string> => {\n  return window.ethereum.request({\n    method: 'eth_sendTransaction',\n    params: [params]\n  })\n}\n","import { createRequire } from 'node:module'\nconst require = createRequire(import.meta.url)\n\n/**\n * The private key used for testing purposes.\n * @constant\n * @type {string}\n */\nexport const PRIVATE_KEY = 'ea084c575a01e2bbefcca3db101eaeab1d8af15554640a510c73692db24d0a6a'\n\nexport const DEFAULT_NETWORK_ID = '0xa'\n\n/**\n * Relative path to the web3-mock bundle.\n * @constant\n * @type {string}\n */\nexport const web3MockPath = require.resolve('@depay/web3-mock/dist/umd/index.bundle.js')\n","import { readFileSync } from 'fs'\nimport { test as base } from '@playwright/test'\nimport { SEED_PHRASE } from '../../constants'\nimport EthereumWalletMock from '../EthereumWalletMock'\nimport { mockEthereum, web3MockPath } from '../utils'\n\ntype EthereumWalletMockFixtures = {\n  ethereumWalletMock: EthereumWalletMock\n}\n\nexport const ethereumWalletMockFixtures = base.extend<EthereumWalletMockFixtures>({\n  context: async ({ context }, use) => {\n    // Dependency and mock function has to be added at the same time - https://playwright.dev/docs/api/class-browsercontext#browser-context-add-init-script\n    await context.addInitScript({\n      content: `${readFileSync(web3MockPath, 'utf-8')}\\n(${mockEthereum.toString()})();`\n    })\n\n    await use(context)\n\n    await context.close()\n  },\n  page: async ({ context }, use) => {\n    const page = await context.newPage()\n\n    await page.goto('/')\n\n    await use(page)\n  },\n  ethereumWalletMock: async ({ page }, use) => {\n    const ethereumWalletMock = new EthereumWalletMock(page)\n\n    await ethereumWalletMock.importWallet(SEED_PHRASE)\n\n    await use(ethereumWalletMock)\n  }\n})\n"]}