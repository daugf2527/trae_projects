{"version":3,"sources":["../src/constants.ts","../src/downloadFile.ts","../src/utils/onDownloadProgress.ts","../src/utils/bytesToMegabytes.ts","../src/unzipArchive.ts","../src/ensureCacheDirExists.ts","../src/utils/getUniqueWalletSetupFunctions.ts","../src/utils/getWalletSetupFiles.ts","../src/utils/importWalletSetupFile.ts","../src/utils/triggerCacheCreation.ts","../src/utils/createCacheForWalletSetupFunction.ts","../src/utils/waitForExtensionOnLoadPage.ts","../src/utils/isDirEmpty.ts","../src/createCache.ts","../src/utils/buildWalletSetupFunction.ts","../src/utils/getWalletSetupFuncHash.ts","../src/defineWalletSetup.ts","../src/utils/createTempContextDir.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/index.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/opt-arg.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/path-arg.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/platform.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/fs.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/rimraf-posix.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/readdir-or-error.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/ignore-enoent.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/rimraf-windows.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/fix-eperm.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/retry-busy.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/rimraf-move-remove.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/default-tmp.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/rimraf-manual.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/rimraf-native.ts","../../../node_modules/.pnpm/rimraf@5.0.5/node_modules/rimraf/src/use-native.ts","../src/utils/removeTempContextDir.ts","../src/prepareExtension.ts","../src/cli/cliEntrypoint.ts","../src/prepareExtensionPhantom.ts","../src/cli/compileWalletSetupFunctions.ts","../src/utils/extractWalletSetupFunction.ts","../src/cli/compilationFixes.ts","../src/cli/footer.ts"],"names":["resolve","path","fs","extensionPath","sleep","glob","root","parse","readdir","lstat","rmdir","unlink","ent","chmod","stat","rename","rm","rmSync","os"],"mappings":"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","sourcesContent":["export const CACHE_DIR_NAME = '.cache-synpress'\n\nexport const WALLET_SETUP_DIR_NAME = 'wallet-setup'\n","import path from 'node:path'\nimport axios from 'axios'\nimport fs from 'fs-extra'\nimport { onDownloadProgress } from './utils/onDownloadProgress'\n\ntype DownloaderOptions = {\n  url: string\n  outputDir: string\n  fileName: string\n  overrideFile?: boolean\n}\n\ntype DownloadFileResult = {\n  filePath: string\n  downloadSkipped: boolean\n}\n\nexport async function downloadFile(options: DownloaderOptions) {\n  const { url, outputDir, fileName, overrideFile } = options\n\n  const returnPromise = new Promise<DownloadFileResult>((resolve, reject) => {\n    const filePath = path.join(outputDir, fileName)\n\n    const fileExists = fs.existsSync(filePath)\n    if (fileExists && !overrideFile) {\n      resolve({\n        filePath,\n        downloadSkipped: true\n      })\n\n      return\n    }\n\n    console.log(`[DEBUG] Downloading file from ${url}`)\n\n    axios\n      .get(url, {\n        responseType: 'stream',\n        onDownloadProgress: onDownloadProgress(url, fileName)\n      })\n      .then((response) => {\n        const writer = fs.createWriteStream(filePath)\n\n        response.data.pipe(writer)\n\n        writer.on('finish', () => {\n          resolve({\n            filePath,\n            downloadSkipped: false\n          })\n        })\n        writer.on('error', (error) => {\n          // TODO: Handle errors in a more sophisticated way\n          reject(new Error(`[Writer] ${error.message}`))\n        })\n      })\n      .catch((error: Error) => {\n        // TODO: Handle errors in a more sophisticated way\n        reject(new Error(`[Axios] ${error.message}`))\n      })\n  })\n\n  // TODO: This is a workaround to handle errors from both `writer` and `axios` and get 100% test coverage.\n  return returnPromise.catch((error: Error) => {\n    throw new Error(`[DownloadFile] Error downloading the file - ${error.message}`)\n  })\n}\n","import type { AxiosProgressEvent } from 'axios'\nimport ProgressBar from 'progress'\nimport { bytesToMegabytes } from './bytesToMegabytes'\n\nexport function onDownloadProgress(url: string, fileName: string) {\n  let progressBar: ProgressBar\n  let lastDownloadedBytes = 0\n\n  return ({ loaded: downloadedBytes, total: totalDownloadBytes }: AxiosProgressEvent) => {\n    if (!totalDownloadBytes) {\n      throw new Error(\n        `[DownloadFile] Request returned total download bytes as 0. This should never happen, and it means that the target file is empty. URL: ${url}`\n      )\n    }\n\n    if (!progressBar) {\n      progressBar = getDownloadProgressBar(url, fileName, totalDownloadBytes)\n    } else {\n      const delta = downloadedBytes - lastDownloadedBytes\n      lastDownloadedBytes = downloadedBytes\n      progressBar.tick(delta)\n    }\n  }\n}\n\nfunction getDownloadProgressBar(url: string, fileName: string, totalBytes: number) {\n  // TODO: This header should be based on the wallet config.\n  const barHeader = url.startsWith('https://github.com/MetaMask/metamask-extension/releases/download/')\n    ? 'ðŸ¦Š MetaMask'\n    : fileName\n\n  const downloadSize = `${bytesToMegabytes(totalBytes)} MB`\n\n  return new ProgressBar(`${barHeader} (${downloadSize}) [:bar] :percent :etas`, {\n    width: 20,\n    complete: '=',\n    incomplete: ' ',\n    total: totalBytes\n  })\n}\n","export function bytesToMegabytes(bytes: number) {\n  const megabytes = bytes / 1024 / 1024\n  return Math.round(megabytes * 10) / 10\n}\n","import path from 'node:path'\nimport fs from 'fs-extra'\nimport unzipCrx from 'unzip-crx-3'\nimport unzippper from 'unzipper'\n\ntype UnzipArchiveOptions = {\n  archivePath: string\n  overwrite?: boolean\n}\n\ntype UnzipArchiveResult = {\n  outputPath: string\n  unzipSkipped: boolean\n}\n\nexport async function unzipArchive(options: UnzipArchiveOptions) {\n  const { archivePath, overwrite } = options\n\n  const resultPromise = new Promise<UnzipArchiveResult>((resolve, reject) => {\n    const archiveFileExtension = archivePath.split('.').slice(-1)\n    const outputPath = archivePath.replace(`.${archiveFileExtension}`, '')\n\n    const fileExists = fs.existsSync(outputPath)\n    if (fileExists && !overwrite) {\n      resolve({\n        outputPath,\n        unzipSkipped: true\n      })\n\n      return\n    }\n\n    // Creates the output directory\n    fs.mkdirSync(outputPath, { recursive: true })\n\n    fs.createReadStream(archivePath)\n      .pipe(unzippper.Parse())\n      .on('entry', function (entry) {\n        const fileName = entry.path\n        const type = entry.type as 'Directory' | 'File'\n\n        if (type === 'Directory') {\n          fs.mkdirSync(path.join(outputPath, fileName), { recursive: true })\n          return\n        }\n\n        if (type === 'File') {\n          const outputFilePath = path.join(outputPath, fileName)\n          const outputFilePathDir = path.dirname(outputFilePath)\n\n          // Handles the rare case when a file is in a directory which has no entry Â¯\\_(ãƒ„)_/Â¯\n          if (!fs.existsSync(outputFilePathDir)) {\n            fs.mkdirSync(outputFilePathDir, { recursive: true })\n          }\n\n          entry.pipe(fs.createWriteStream(outputFilePath))\n        }\n      })\n      .promise()\n      .then(() => {\n        resolve({\n          outputPath,\n          unzipSkipped: false\n        })\n      })\n      .catch((error: Error) => {\n        fs.unlinkSync(outputPath)\n        reject(new Error(`[Pipe] ${error.message}`))\n      })\n  })\n\n  // TODO: Handle errors in a more sophisticated way\n  return resultPromise.catch((error: Error) => {\n    throw new Error(`[UnzipFile] Error unzipping the file - ${error.message}`)\n  })\n}\n\nexport async function unzipArchivePhantom(options: UnzipArchiveOptions) {\n  const { archivePath, overwrite } = options\n\n  const archiveFileExtension = archivePath.split('.').slice(-1)\n  const outputPath = archivePath.replace(`.${archiveFileExtension}`, '')\n\n  const fileExists = fs.existsSync(outputPath)\n  if (fileExists && !overwrite) {\n    return {\n      outputPath,\n      unzipSkipped: true\n    }\n  }\n\n  // Creates the output directory\n  fs.mkdirSync(outputPath, { recursive: true })\n\n  await unzipCrx(archivePath, outputPath)\n\n  // TODO: Handle errors\n\n  return { outputPath }\n}\n","import path from 'node:path'\nimport fs from 'fs-extra'\nimport { CACHE_DIR_NAME } from './constants'\n\nexport function ensureCacheDirExists() {\n  const cacheDirPath = path.join(process.cwd(), CACHE_DIR_NAME)\n  fs.ensureDirSync(cacheDirPath)\n  return cacheDirPath\n}\n","import path from 'node:path'\nimport type { WalletSetupFunction } from '../defineWalletSetup'\nimport { getWalletSetupFiles } from './getWalletSetupFiles'\nimport { importWalletSetupFile } from './importWalletSetupFile'\n\ntype DuplicatesMap = Record<string, { fileName: string; setupFunction: WalletSetupFunction }[]>\n\nexport async function getUniqueWalletSetupFunctions(walletSetupDirPath: string) {\n  const fileList = await getWalletSetupFiles(walletSetupDirPath)\n\n  const setupFunctions = new Map<string, { fileName: string; setupFunction: WalletSetupFunction }>()\n\n  const duplicatesMap: DuplicatesMap = {}\n\n  for (const fileName of fileList) {\n    const walletSetupFilePath = path.join(walletSetupDirPath, fileName)\n    const { hash, fn } = await importWalletSetupFile(walletSetupFilePath)\n\n    const entry = {\n      fileName,\n      setupFunction: fn\n    }\n\n    // Since we're checking for duplicates later, we can safely forget about overwriting.\n    setupFunctions.set(hash, entry)\n\n    if (duplicatesMap[hash]) {\n      duplicatesMap[hash]?.push(entry)\n    } else {\n      duplicatesMap[hash] = [entry]\n    }\n  }\n\n  throwIfThereAreDuplicatedHashes(duplicatesMap)\n\n  return setupFunctions\n}\n\nfunction throwIfThereAreDuplicatedHashes(duplicatesMap: DuplicatesMap) {\n  const duplicatedHashes = Object.entries(duplicatesMap).filter(\n    ([, setupFunctionsArray]) => setupFunctionsArray.length > 1\n  )\n\n  if (duplicatedHashes.length === 0) {\n    return\n  }\n\n  const sortedDuplicatedHashes = duplicatedHashes.sort(([hashA], [hashB]) => hashA.localeCompare(hashB))\n\n  throw new Error(\n    [\n      '[GetUniqueWalletSetupFunctions] There are identical wallet setup functions:',\n      sortedDuplicatedHashes\n        .map(([hash, setupFunctionsArray]) => {\n          return `\\t${hash} - [${setupFunctionsArray.map(({ fileName }) => fileName).join(', ')}]`\n        })\n        .join('\\n')\n    ].join('\\n')\n  )\n}\n","import fs from 'fs-extra'\n\nconst SETUP_FILE_FILTER_REGEX = /\\.setup\\.(ts|js|mjs)$/\n\nexport async function getWalletSetupFiles(walletSetupDirPath: string) {\n  await fs.access(walletSetupDirPath).catch((e) => {\n    // TODO: This should utilize the `e.code`.\n    // TODO: See: https://nodejs.org/api/fs.html#fsexistspath-callback\n    // TODO: See fix: https://stackoverflow.com/a/49562477\n    // TODO: Replace ALL occurrences of `fs.exists` with `fs.access`.\n    if (e instanceof Error && e.message.includes('ENOENT')) {\n      throw new Error(`[GetWalletSetupFiles] Wallet setup directory does not exist at ${walletSetupDirPath}`)\n    }\n\n    throw e\n  })\n\n  const setupFilesFilter = (file: string) => file.match(SETUP_FILE_FILTER_REGEX)\n  const fileList = (await fs.readdir(walletSetupDirPath)).filter(setupFilesFilter)\n\n  if (!fileList.length) {\n    throw new Error(\n      [\n        `[GetWalletSetupFiles] No wallet setup files found at ${walletSetupDirPath}`,\n        'Remember that all wallet setup files must end with `.setup.{ts,js,mjs}` extension!'\n      ].join('\\n')\n    )\n  }\n\n  return fileList.sort()\n}\n","import { z } from 'zod'\nimport type { WalletSetupFunction } from '../defineWalletSetup'\n\n// TODO: Add hash length validation.\nconst WalletSetupModule = z.object({\n  default: z.object({\n    hash: z.string(),\n    fn: z.function().returns(z.promise(z.void()))\n  })\n})\n\nexport async function importWalletSetupFile(walletSetupFilePath: string) {\n  const walletSetupModule = await import(walletSetupFilePath)\n\n  const result = WalletSetupModule.safeParse(walletSetupModule)\n  if (!result.success) {\n    throw new Error(\n      [\n        `[ImportWalletSetupFile] Invalid wallet setup function at ${walletSetupFilePath}`,\n        'Remember that all wallet setup files must export the wallet setup function as a default export!'\n      ].join('\\n')\n    )\n  }\n\n  const { hash, fn } = result.data.default\n\n  // TODO: Can we somehow validate this function type with Zod?\n  return {\n    hash,\n    fn: fn as WalletSetupFunction\n  }\n}\n","import path from 'node:path'\nimport fs from 'fs-extra'\nimport type { WalletSetupFunction } from '../defineWalletSetup'\nimport { ensureCacheDirExists } from '../ensureCacheDirExists'\nimport { createCacheForWalletSetupFunction } from './createCacheForWalletSetupFunction'\nimport { isDirEmpty } from './isDirEmpty'\n\nexport async function triggerCacheCreation(\n  setupFunctions: Map<string, { fileName: string; setupFunction: WalletSetupFunction }>,\n  hashes: string[],\n  downloadExtension: () => Promise<string>,\n  force: boolean\n) {\n  const cacheDirPath = ensureCacheDirExists()\n  const extensionPath = await downloadExtension()\n\n  return await Promise.all(\n    Array.from(setupFunctions).map(async ([_, { fileName, setupFunction }], index) => {\n      if (!hashes[index]) {\n        throw new Error(`No hash found for ${fileName}`)\n      }\n\n      const funcHash = hashes[index]\n\n      const cachePath = path.join(cacheDirPath, funcHash || 'unknown')\n      const doesCacheDirExist = await fs.exists(cachePath)\n      const isCacheDirEmpty = await isDirEmpty(cachePath)\n\n      if (doesCacheDirExist) {\n        if (isCacheDirEmpty) {\n          // In case of incorrect Playwright setup, the cache dir will be empty. For now, we're just deleting it.\n          await fs.remove(cachePath)\n        } else {\n          if (!force) {\n            console.log(`Cache already exists for ${funcHash}. Skipping...`)\n            return\n          }\n\n          console.log(`Cache already exists for ${funcHash} but force flag is set. Deleting cache...`)\n          await fs.remove(cachePath)\n        }\n      }\n\n      const fileNameWithCorrectExtension = fileName.replace(/\\.(ts|js|mjs)$/, '.{ts,js,mjs}')\n      console.log(`Triggering cache creation for: ${funcHash} (${fileNameWithCorrectExtension})`)\n      // We're not inferring the return type here to make sure we don't accidentally await the function.\n      return createCacheForWalletSetupFunction(extensionPath, cachePath, setupFunction, fileNameWithCorrectExtension)\n    })\n  )\n}\n","import { chromium } from 'playwright-core'\nimport type { WalletSetupFunction } from '../defineWalletSetup'\nimport { waitForExtensionOnLoadPage } from './waitForExtensionOnLoadPage'\n\n// Inlining the sleep function here cause this is one of the few places in the entire codebase where sleep should be used!\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\nexport async function createCacheForWalletSetupFunction(\n  extensionPath: string,\n  contextCacheDirPath: string,\n  walletSetup: WalletSetupFunction,\n  fileName: string\n) {\n  // TODO: Extract & Make a constant.\n  const browserArgs = [`--disable-extensions-except=${extensionPath}`, `--load-extension=${extensionPath}`]\n\n  if (process.env.HEADLESS) {\n    browserArgs.push('--headless=new')\n  }\n\n  const context = await chromium.launchPersistentContext(contextCacheDirPath, {\n    headless: false,\n    args: browserArgs\n  })\n\n  const extensionPage = await waitForExtensionOnLoadPage(context, extensionPath)\n\n  try {\n    await walletSetup(context, extensionPage)\n  } catch (e) {\n    throw new Error(\n      `[CORE] Encountered an error while executing wallet setup function from file ${fileName}. Error message: ${\n        (e as Error).message\n      }`\n    )\n  }\n\n  // We sleep here to give the browser enough time to save the context to the disk.\n  await sleep(3000) // TODO: Extract & Make this timeout configurable.\n\n  await context.close()\n\n  return\n}\n","import { type BrowserContext, type Page, errors as playwrightErrors } from 'playwright-core'\n\n// Increase timeout for CI environments\nconst EXTENSION_LOAD_TIMEOUT = 10000\n// Increase max retries for CI environments\nconst MAX_RETRIES = 3\n// Add delay between retries\nconst RETRY_DELAY_BASE = 1000\n// Initial delay to ensure browser is fully initialized\nconst INITIAL_BROWSER_DELAY = 1000\n// Max retries for fixing blank pages\nconst MAX_BLANK_PAGE_RETRIES = 5\n// Delay after page reload\nconst RELOAD_DELAY = 1000\n// Polling interval for finding extension page\nconst POLLING_INTERVAL = 500\n\nconst APP_SELECTORS = {\n  METAMASK: '#app-content .app',\n  PHANTOM: '#root'\n}\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n/**\n * Checks if a page is blank (no MetaMask or Phantom app content)\n */\nasync function isPageBlank(page: Page, extensionPath: string): Promise<boolean> {\n  const app = (extensionPath: string) => {\n    if (extensionPath.includes('metamask')) {\n      return 'METAMASK'\n    } else {\n      return 'PHANTOM'\n    }\n  }\n\n  try {\n    // Check for specific app element\n    const appElementCount = await page\n      .locator(APP_SELECTORS[app(extensionPath)])\n      .count()\n      .catch(() => 0)\n\n    if (appElementCount === 0) {\n      console.log(`[WaitForExtensionOnLoadPage] ${app(extensionPath)} app element not found, page appears to be blank`)\n      return true\n    }\n\n    return false\n  } catch (e) {\n    console.warn(\n      `[WaitForExtensionOnLoadPage] Error checking if page is blank: ${e instanceof Error ? e.message : String(e)}`\n    )\n    return true // Assume blank if we can't check\n  }\n}\n\n/**\n * Attempts to fix a blank page by reloading\n */\nasync function fixBlankPage(page: Page, extensionPath: string): Promise<boolean> {\n  for (let attempt = 0; attempt < MAX_BLANK_PAGE_RETRIES; attempt++) {\n    console.log(`[WaitForExtensionOnLoadPage] Checking page state (attempt ${attempt + 1}/${MAX_BLANK_PAGE_RETRIES})`)\n\n    const isBlank = await isPageBlank(page, extensionPath)\n\n    if (isBlank) {\n      console.log('[WaitForExtensionOnLoadPage] Page is blank, reloading...')\n      await page.reload()\n      await sleep(RELOAD_DELAY)\n    } else {\n      console.log('[WaitForExtensionOnLoadPage] Page appears to be loaded correctly')\n      return true\n    }\n  }\n\n  console.warn('[WaitForExtensionOnLoadPage] Failed to fix blank/error page after multiple attempts')\n  return false\n}\n\n/**\n * Finds an extension page in the current browser context\n */\nasync function findExtensionPage(context: BrowserContext): Promise<Page | null> {\n  const pages = context.pages()\n  const extensionPage = pages.find((page) => {\n    try {\n      const url = page.url()\n      return url.startsWith('chrome-extension://')\n    } catch (e) {\n      return false\n    }\n  })\n\n  return extensionPage || null\n}\n\n/**\n * Waits for the extension page to load and ensures it's not blank or has errors\n */\nexport async function waitForExtensionOnLoadPage(context: BrowserContext, extensionPath: string): Promise<Page> {\n  let retries = 0\n  console.log(\n    `[WaitForExtensionOnLoadPage] Starting with timeout: ${EXTENSION_LOAD_TIMEOUT}ms and max retries: ${MAX_RETRIES}`\n  )\n\n  // Initial delay to ensure browser is fully initialized\n  console.log(`[WaitForExtensionOnLoadPage] Waiting ${INITIAL_BROWSER_DELAY}ms for browser to initialize...`)\n  await sleep(INITIAL_BROWSER_DELAY)\n\n  const startTime = Date.now()\n\n  while (retries <= MAX_RETRIES) {\n    try {\n      console.log(\n        `[WaitForExtensionOnLoadPage] Looking for extension page (attempt ${retries + 1}/${MAX_RETRIES + 1})...`\n      )\n\n      // Poll for extension page until timeout\n      let extensionPage: Page | null = null\n      let pollingAttempts = 0\n      const maxPollingAttempts = Math.floor(EXTENSION_LOAD_TIMEOUT / POLLING_INTERVAL)\n\n      while (pollingAttempts < maxPollingAttempts) {\n        extensionPage = await findExtensionPage(context)\n\n        if (extensionPage) {\n          console.log(`[WaitForExtensionOnLoadPage] Found extension page after ${pollingAttempts + 1} polling attempts`)\n          break\n        }\n\n        pollingAttempts++\n        console.log(\n          `[WaitForExtensionOnLoadPage] No extension page found, polling (${pollingAttempts}/${maxPollingAttempts})...`\n        )\n        await sleep(POLLING_INTERVAL)\n      }\n\n      if (!extensionPage) {\n        throw new playwrightErrors.TimeoutError(\n          `Timed out waiting for extension page after ${EXTENSION_LOAD_TIMEOUT}ms`\n        )\n      }\n\n      // Now check if the page is blank or has errors and fix if needed\n      console.log('[WaitForExtensionOnLoadPage] Checking if extension page is properly loaded...')\n      const isFixed = await fixBlankPage(extensionPage, extensionPath)\n\n      if (isFixed) {\n        console.log('[WaitForExtensionOnLoadPage] Extension page is properly loaded and ready')\n        return extensionPage\n      } else {\n        throw new Error('Failed to fix blank or error page')\n      }\n    } catch (e) {\n      retries++\n\n      // Log more detailed information about the current browser state\n      const pages = context.pages()\n      console.log(`[WaitForExtensionOnLoadPage] Current browser has ${pages.length} pages open`)\n      for (let i = 0; i < pages.length; i++) {\n        const page = pages[i]\n        if (page) {\n          try {\n            console.log(`[WaitForExtensionOnLoadPage] Page ${i + 1}: ${page.url()}`)\n          } catch (urlError) {\n            console.log(`[WaitForExtensionOnLoadPage] Page ${i + 1}: Unable to get URL`)\n          }\n        }\n      }\n\n      if (retries <= MAX_RETRIES) {\n        const delayTime = RETRY_DELAY_BASE * retries\n        console.warn(\n          `[WaitForExtensionOnLoadPage] Extension page issue, retrying (attempt ${retries}/${MAX_RETRIES}) after ${delayTime}ms delay...`\n        )\n\n        await sleep(delayTime)\n        continue\n      }\n\n      const elapsedTime = Date.now() - startTime\n      throw new Error(\n        `[WaitForExtensionOnLoadPage] Extension failed to load properly after ${elapsedTime}ms and ${retries} attempts!`\n      )\n    }\n  }\n\n  // This should never be reached\n  throw new Error('[WaitForExtensionOnLoadPage] Unexpected end of function reached')\n}\n","import fs from 'fs-extra'\n\nexport async function isDirEmpty(dirPath: string) {\n  try {\n    const files = await fs.readdir(dirPath)\n\n    return files.length === 0\n  } catch (e) {\n    if (e instanceof Error && e.message.includes('ENOENT')) {\n      return true\n    }\n\n    throw e\n  }\n}\n","import { getUniqueWalletSetupFunctions } from './utils/getUniqueWalletSetupFunctions'\nimport { triggerCacheCreation } from './utils/triggerCacheCreation'\n\nexport async function createCache(\n  walletSetupDirPath: string,\n  hashes: string[],\n  downloadExtension: () => Promise<string>,\n  force = false\n) {\n  const setupFunctions = await getUniqueWalletSetupFunctions(walletSetupDirPath)\n\n  const cacheCreationOutput = await triggerCacheCreation(setupFunctions, hashes, downloadExtension, force)\n\n  if (cacheCreationOutput.length === 0) {\n    console.log('No new setup functions to cache. Exiting...')\n    return\n  }\n\n  console.log('All wallet setup functions are now cached!')\n}\n","import { transformSync } from 'esbuild'\n\nexport default function buildWalletSetupFunction(walletSetupFunctionString: string) {\n  const { code } = transformSync(walletSetupFunctionString, {\n    format: 'esm',\n    minifyWhitespace: true,\n    target: 'es2022',\n    drop: ['console', 'debugger'],\n    loader: 'ts',\n    logLevel: 'silent',\n    platform: 'node'\n  })\n\n  return code\n}\n","import { createHash } from 'node:crypto'\n\n// Same length as the file part (first part before the `-`) of a Playwright Test ID.\nexport const WALLET_SETUP_FUNC_HASH_LENGTH = 10\n\nexport function getWalletSetupFuncHash(walletSetupString: string) {\n  const hash = createHash('shake256', {\n    outputLength: WALLET_SETUP_FUNC_HASH_LENGTH\n  })\n\n  return hash.update(walletSetupString).digest('hex')\n}\n","import type { BrowserContext, Page } from 'playwright-core'\nimport buildWalletSetupFunction from './utils/buildWalletSetupFunction'\nimport { getWalletSetupFuncHash } from './utils/getWalletSetupFuncHash'\n\n// TODO: Should we export this type in the `release` package?\nexport type WalletSetupFunction = (context: BrowserContext, walletPage: Page) => Promise<void>\n\n// TODO: This runs at least twice. Should we cache it somehow?\n/**\n * This function is used to define how a wallet should be set up.\n * Based on the contents of this function, a browser with the wallet extension is set up and cached so that it can be used by the tests later.\n *\n * @param walletPassword - The password of the wallet.\n * @param fn - A function describing the setup of the wallet.\n *\n * @returns An object containing the hash of the function, the function itself, and the wallet password. The `testWithWalletSetup` function uses this object.\n */\nexport function defineWalletSetup(walletPassword: string, fn: WalletSetupFunction) {\n  const walletSetupFunction = buildWalletSetupFunction(fn.toString())\n\n  const hash = getWalletSetupFuncHash(walletSetupFunction)\n\n  return {\n    hash,\n    fn,\n    walletPassword\n  }\n}\n","import os from 'node:os'\nimport path from 'node:path'\nimport fs from 'fs-extra'\n\n/**\n * Creates a temporary context directory.\n * This directory should be created per-worker basis.\n *\n * This function mirrors the one found in the Playwright source code:\n * https://github.com/microsoft/playwright/blob/d1d5fc67dc684a5d4b682749e59bba8cc0ad14de/packages/playwright-core/src/server/browserType.ts#L161\n */\nexport async function createTempContextDir(browserName: string, testId: string) {\n  return await fs.mkdtemp(path.join(os.tmpdir(), `synpress_${browserName}_${testId}_`))\n}\n","import { glob, globSync } from 'glob'\nimport {\n  optArg,\n  optArgSync,\n  RimrafAsyncOptions,\n  RimrafSyncOptions,\n} from './opt-arg.js'\nimport pathArg from './path-arg.js'\nimport { rimrafManual, rimrafManualSync } from './rimraf-manual.js'\nimport { rimrafMoveRemove, rimrafMoveRemoveSync } from './rimraf-move-remove.js'\nimport { rimrafNative, rimrafNativeSync } from './rimraf-native.js'\nimport { rimrafPosix, rimrafPosixSync } from './rimraf-posix.js'\nimport { rimrafWindows, rimrafWindowsSync } from './rimraf-windows.js'\nimport { useNative, useNativeSync } from './use-native.js'\n\nexport {\n  assertRimrafOptions,\n  isRimrafOptions,\n  RimrafAsyncOptions,\n  RimrafOptions,\n  RimrafSyncOptions,\n} from './opt-arg.js'\n\nconst wrap =\n  (fn: (p: string, o: RimrafAsyncOptions) => Promise<boolean>) =>\n  async (\n    path: string | string[],\n    opt?: RimrafAsyncOptions\n  ): Promise<boolean> => {\n    const options = optArg(opt)\n    if (options.glob) {\n      path = await glob(path, options.glob)\n    }\n    if (Array.isArray(path)) {\n      return !!(\n        await Promise.all(path.map(p => fn(pathArg(p, options), options)))\n      ).reduce((a, b) => a && b, true)\n    } else {\n      return !!(await fn(pathArg(path, options), options))\n    }\n  }\n\nconst wrapSync =\n  (fn: (p: string, o: RimrafSyncOptions) => boolean) =>\n  (path: string | string[], opt?: RimrafSyncOptions): boolean => {\n    const options = optArgSync(opt)\n    if (options.glob) {\n      path = globSync(path, options.glob)\n    }\n    if (Array.isArray(path)) {\n      return !!path\n        .map(p => fn(pathArg(p, options), options))\n        .reduce((a, b) => a && b, true)\n    } else {\n      return !!fn(pathArg(path, options), options)\n    }\n  }\n\nexport const nativeSync = wrapSync(rimrafNativeSync)\nexport const native = Object.assign(wrap(rimrafNative), { sync: nativeSync })\n\nexport const manualSync = wrapSync(rimrafManualSync)\nexport const manual = Object.assign(wrap(rimrafManual), { sync: manualSync })\n\nexport const windowsSync = wrapSync(rimrafWindowsSync)\nexport const windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync })\n\nexport const posixSync = wrapSync(rimrafPosixSync)\nexport const posix = Object.assign(wrap(rimrafPosix), { sync: posixSync })\n\nexport const moveRemoveSync = wrapSync(rimrafMoveRemoveSync)\nexport const moveRemove = Object.assign(wrap(rimrafMoveRemove), {\n  sync: moveRemoveSync,\n})\n\nexport const rimrafSync = wrapSync((path, opt) =>\n  useNativeSync(opt) ? rimrafNativeSync(path, opt) : rimrafManualSync(path, opt)\n)\nexport const sync = rimrafSync\n\nconst rimraf_ = wrap((path, opt) =>\n  useNative(opt) ? rimrafNative(path, opt) : rimrafManual(path, opt)\n)\nexport const rimraf = Object.assign(rimraf_, {\n  rimraf: rimraf_,\n  sync: rimrafSync,\n  rimrafSync: rimrafSync,\n  manual,\n  manualSync,\n  native,\n  nativeSync,\n  posix,\n  posixSync,\n  windows,\n  windowsSync,\n  moveRemove,\n  moveRemoveSync,\n})\nrimraf.rimraf = rimraf\n","import { Dirent, Stats } from 'fs'\nimport { GlobOptions } from 'glob'\n\nconst typeOrUndef = (val: any, t: string) =>\n  typeof val === 'undefined' || typeof val === t\n\nexport const isRimrafOptions = (o: any): o is RimrafOptions =>\n  !!o &&\n  typeof o === 'object' &&\n  typeOrUndef(o.preserveRoot, 'boolean') &&\n  typeOrUndef(o.tmp, 'string') &&\n  typeOrUndef(o.maxRetries, 'number') &&\n  typeOrUndef(o.retryDelay, 'number') &&\n  typeOrUndef(o.backoff, 'number') &&\n  typeOrUndef(o.maxBackoff, 'number') &&\n  (typeOrUndef(o.glob, 'boolean') || (o.glob && typeof o.glob === 'object')) &&\n  typeOrUndef(o.filter, 'function')\n\nexport const assertRimrafOptions: (o: any) => void = (\n  o: any\n): asserts o is RimrafOptions => {\n  if (!isRimrafOptions(o)) {\n    throw new Error('invalid rimraf options')\n  }\n}\n\nexport interface RimrafAsyncOptions {\n  preserveRoot?: boolean\n  tmp?: string\n  maxRetries?: number\n  retryDelay?: number\n  backoff?: number\n  maxBackoff?: number\n  signal?: AbortSignal\n  glob?: boolean | GlobOptions\n  filter?:\n    | ((path: string, ent: Dirent | Stats) => boolean)\n    | ((path: string, ent: Dirent | Stats) => Promise<boolean>)\n}\n\nexport interface RimrafSyncOptions extends RimrafAsyncOptions {\n  filter?: (path: string, ent: Dirent | Stats) => boolean\n}\n\nexport type RimrafOptions = RimrafSyncOptions | RimrafAsyncOptions\n\nconst optArgT = <T extends RimrafOptions>(\n  opt: T\n):\n  | (T & {\n      glob: GlobOptions & { withFileTypes: false }\n    })\n  | (T & { glob: undefined }) => {\n  assertRimrafOptions(opt)\n  const { glob, ...options } = opt\n  if (!glob) {\n    return options as T & { glob: undefined }\n  }\n  const globOpt =\n    glob === true\n      ? opt.signal\n        ? { signal: opt.signal }\n        : {}\n      : opt.signal\n      ? {\n          signal: opt.signal,\n          ...glob,\n        }\n      : glob\n  return {\n    ...options,\n    glob: {\n      ...globOpt,\n      // always get absolute paths from glob, to ensure\n      // that we are referencing the correct thing.\n      absolute: true,\n      withFileTypes: false,\n    },\n  } as T & { glob: GlobOptions & { withFileTypes: false } }\n}\n\nexport const optArg = (opt: RimrafAsyncOptions = {}) => optArgT(opt)\nexport const optArgSync = (opt: RimrafSyncOptions = {}) => optArgT(opt)\n","import { parse, resolve } from 'path'\nimport { inspect } from 'util'\nimport { RimrafAsyncOptions } from './index.js'\nimport platform from './platform.js'\n\nconst pathArg = (path: string, opt: RimrafAsyncOptions = {}) => {\n  const type = typeof path\n  if (type !== 'string') {\n    const ctor = path && type === 'object' && path.constructor\n    const received =\n      ctor && ctor.name\n        ? `an instance of ${ctor.name}`\n        : type === 'object'\n        ? inspect(path)\n        : `type ${type} ${path}`\n    const msg =\n      'The \"path\" argument must be of type string. ' + `Received ${received}`\n    throw Object.assign(new TypeError(msg), {\n      path,\n      code: 'ERR_INVALID_ARG_TYPE',\n    })\n  }\n\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    const msg = 'path must be a string without null bytes'\n    throw Object.assign(new TypeError(msg), {\n      path,\n      code: 'ERR_INVALID_ARG_VALUE',\n    })\n  }\n\n  path = resolve(path)\n  const { root } = parse(path)\n\n  if (path === root && opt.preserveRoot !== false) {\n    const msg = 'refusing to remove root directory without preserveRoot:false'\n    throw Object.assign(new Error(msg), {\n      path,\n      code: 'ERR_PRESERVE_ROOT',\n    })\n  }\n\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const { root } = parse(path)\n    if (badWinChars.test(path.substring(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\n\nexport default pathArg\n","export default process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform\n","// promisify ourselves, because older nodes don't have fs.promises\n\nimport fs, { Dirent } from 'fs'\n\n// sync ones just take the sync version from node\nexport {\n  chmodSync,\n  mkdirSync,\n  renameSync,\n  rmdirSync,\n  rmSync,\n  statSync,\n  lstatSync,\n  unlinkSync,\n} from 'fs'\n\nimport { readdirSync as rdSync } from 'fs'\nexport const readdirSync = (path: fs.PathLike): Dirent[] =>\n  rdSync(path, { withFileTypes: true })\n\n// unrolled for better inlining, this seems to get better performance\n// than something like:\n// const makeCb = (res, rej) => (er, ...d) => er ? rej(er) : res(...d)\n// which would be a bit cleaner.\n\nconst chmod = (path: fs.PathLike, mode: fs.Mode): Promise<void> =>\n  new Promise((res, rej) =>\n    fs.chmod(path, mode, (er, ...d: any[]) => (er ? rej(er) : res(...d)))\n  )\n\nconst mkdir = (\n  path: fs.PathLike,\n  options?:\n    | fs.Mode\n    | (fs.MakeDirectoryOptions & { recursive?: boolean | null })\n    | undefined\n    | null\n): Promise<string | undefined> =>\n  new Promise((res, rej) =>\n    fs.mkdir(path, options, (er, made) => (er ? rej(er) : res(made)))\n  )\n\nconst readdir = (path: fs.PathLike): Promise<Dirent[]> =>\n  new Promise<Dirent[]>((res, rej) =>\n    fs.readdir(path, { withFileTypes: true }, (er, data) =>\n      er ? rej(er) : res(data)\n    )\n  )\n\nconst rename = (oldPath: fs.PathLike, newPath: fs.PathLike): Promise<void> =>\n  new Promise((res, rej) =>\n    fs.rename(oldPath, newPath, (er, ...d: any[]) => (er ? rej(er) : res(...d)))\n  )\n\nconst rm = (path: fs.PathLike, options: fs.RmOptions): Promise<void> =>\n  new Promise((res, rej) =>\n    fs.rm(path, options, (er, ...d: any[]) => (er ? rej(er) : res(...d)))\n  )\n\nconst rmdir = (path: fs.PathLike): Promise<void> =>\n  new Promise((res, rej) =>\n    fs.rmdir(path, (er, ...d: any[]) => (er ? rej(er) : res(...d)))\n  )\n\nconst stat = (path: fs.PathLike): Promise<fs.Stats> =>\n  new Promise((res, rej) =>\n    fs.stat(path, (er, data) => (er ? rej(er) : res(data)))\n  )\n\nconst lstat = (path: fs.PathLike): Promise<fs.Stats> =>\n  new Promise((res, rej) =>\n    fs.lstat(path, (er, data) => (er ? rej(er) : res(data)))\n  )\n\nconst unlink = (path: fs.PathLike): Promise<void> =>\n  new Promise((res, rej) =>\n    fs.unlink(path, (er, ...d: any[]) => (er ? rej(er) : res(...d)))\n  )\n\nexport const promises = {\n  chmod,\n  mkdir,\n  readdir,\n  rename,\n  rm,\n  rmdir,\n  stat,\n  lstat,\n  unlink,\n}\n","// the simple recursive removal, where unlink and rmdir are atomic\n// Note that this approach does NOT work on Windows!\n// We stat first and only unlink if the Dirent isn't a directory,\n// because sunos will let root unlink a directory, and some\n// SUPER weird breakage happens as a result.\n\nimport { lstatSync, promises, rmdirSync, unlinkSync } from './fs.js'\nconst { lstat, rmdir, unlink } = promises\n\nimport { parse, resolve } from 'path'\n\nimport { readdirOrError, readdirOrErrorSync } from './readdir-or-error.js'\n\nimport { Dirent, Stats } from 'fs'\nimport { RimrafAsyncOptions, RimrafSyncOptions } from './index.js'\nimport { ignoreENOENT, ignoreENOENTSync } from './ignore-enoent.js'\n\nexport const rimrafPosix = async (path: string, opt: RimrafAsyncOptions) => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  try {\n    return await rimrafPosixDir(path, opt, await lstat(path))\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') return true\n    throw er\n  }\n}\n\nexport const rimrafPosixSync = (path: string, opt: RimrafSyncOptions) => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  try {\n    return rimrafPosixDirSync(path, opt, lstatSync(path))\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') return true\n    throw er\n  }\n}\n\nconst rimrafPosixDir = async (\n  path: string,\n  opt: RimrafAsyncOptions,\n  ent: Dirent | Stats\n): Promise<boolean> => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  const entries = ent.isDirectory() ? await readdirOrError(path) : null\n  if (!Array.isArray(entries)) {\n    // this can only happen if lstat/readdir lied, or if the dir was\n    // swapped out with a file at just the right moment.\n    /* c8 ignore start */\n    if (entries) {\n      if (entries.code === 'ENOENT') {\n        return true\n      }\n      if (entries.code !== 'ENOTDIR') {\n        throw entries\n      }\n    }\n    /* c8 ignore stop */\n    if (opt.filter && !(await opt.filter(path, ent))) {\n      return false\n    }\n    await ignoreENOENT(unlink(path))\n    return true\n  }\n\n  const removedAll = (\n    await Promise.all(\n      entries.map(ent => rimrafPosixDir(resolve(path, ent.name), opt, ent))\n    )\n  ).reduce((a, b) => a && b, true)\n\n  if (!removedAll) {\n    return false\n  }\n\n  // we don't ever ACTUALLY try to unlink /, because that can never work\n  // but when preserveRoot is false, we could be operating on it.\n  // No need to check if preserveRoot is not false.\n  if (opt.preserveRoot === false && path === parse(path).root) {\n    return false\n  }\n\n  if (opt.filter && !(await opt.filter(path, ent))) {\n    return false\n  }\n\n  await ignoreENOENT(rmdir(path))\n  return true\n}\n\nconst rimrafPosixDirSync = (\n  path: string,\n  opt: RimrafSyncOptions,\n  ent: Dirent | Stats\n): boolean => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  const entries = ent.isDirectory() ? readdirOrErrorSync(path) : null\n  if (!Array.isArray(entries)) {\n    // this can only happen if lstat/readdir lied, or if the dir was\n    // swapped out with a file at just the right moment.\n    /* c8 ignore start */\n    if (entries) {\n      if (entries.code === 'ENOENT') {\n        return true\n      }\n      if (entries.code !== 'ENOTDIR') {\n        throw entries\n      }\n    }\n    /* c8 ignore stop */\n    if (opt.filter && !opt.filter(path, ent)) {\n      return false\n    }\n    ignoreENOENTSync(() => unlinkSync(path))\n    return true\n  }\n  let removedAll: boolean = true\n  for (const ent of entries) {\n    const p = resolve(path, ent.name)\n    removedAll = rimrafPosixDirSync(p, opt, ent) && removedAll\n  }\n  if (opt.preserveRoot === false && path === parse(path).root) {\n    return false\n  }\n\n  if (!removedAll) {\n    return false\n  }\n\n  if (opt.filter && !opt.filter(path, ent)) {\n    return false\n  }\n\n  ignoreENOENTSync(() => rmdirSync(path))\n  return true\n}\n","// returns an array of entries if readdir() works,\n// or the error that readdir() raised if not.\nimport { promises, readdirSync } from './fs.js'\nconst { readdir } = promises\nexport const readdirOrError = (path: string) =>\n  readdir(path).catch(er => er as NodeJS.ErrnoException)\nexport const readdirOrErrorSync = (path: string) => {\n  try {\n    return readdirSync(path)\n  } catch (er) {\n    return er as NodeJS.ErrnoException\n  }\n}\n","export const ignoreENOENT = async (p: Promise<any>) =>\n  p.catch(er => {\n    if (er.code !== 'ENOENT') {\n      throw er\n    }\n  })\n\nexport const ignoreENOENTSync = (fn: () => any) => {\n  try {\n    return fn()\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n","// This is the same as rimrafPosix, with the following changes:\n//\n// 1. EBUSY, ENFILE, EMFILE trigger retries and/or exponential backoff\n// 2. All non-directories are removed first and then all directories are\n//    removed in a second sweep.\n// 3. If we hit ENOTEMPTY in the second sweep, fall back to move-remove on\n//    the that folder.\n//\n// Note: \"move then remove\" is 2-10 times slower, and just as unreliable.\n\nimport { Dirent, Stats } from 'fs'\nimport { parse, resolve } from 'path'\nimport { RimrafAsyncOptions, RimrafSyncOptions } from './index.js'\nimport { fixEPERM, fixEPERMSync } from './fix-eperm.js'\nimport { lstatSync, promises, rmdirSync, unlinkSync } from './fs.js'\nimport { ignoreENOENT, ignoreENOENTSync } from './ignore-enoent.js'\nimport { readdirOrError, readdirOrErrorSync } from './readdir-or-error.js'\nimport { retryBusy, retryBusySync } from './retry-busy.js'\nimport { rimrafMoveRemove, rimrafMoveRemoveSync } from './rimraf-move-remove.js'\nconst { unlink, rmdir, lstat } = promises\n\nconst rimrafWindowsFile = retryBusy(fixEPERM(unlink))\nconst rimrafWindowsFileSync = retryBusySync(fixEPERMSync(unlinkSync))\nconst rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir))\nconst rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(rmdirSync))\n\nconst rimrafWindowsDirMoveRemoveFallback = async (\n  path: string,\n  opt: RimrafAsyncOptions\n): Promise<boolean> => {\n  /* c8 ignore start */\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  /* c8 ignore stop */\n  // already filtered, remove from options so we don't call unnecessarily\n  const { filter, ...options } = opt\n  try {\n    return await rimrafWindowsDirRetry(path, options)\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOTEMPTY') {\n      return await rimrafMoveRemove(path, options)\n    }\n    throw er\n  }\n}\n\nconst rimrafWindowsDirMoveRemoveFallbackSync = (\n  path: string,\n  opt: RimrafSyncOptions\n): boolean => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  // already filtered, remove from options so we don't call unnecessarily\n  const { filter, ...options } = opt\n  try {\n    return rimrafWindowsDirRetrySync(path, options)\n  } catch (er) {\n    const fer = er as NodeJS.ErrnoException\n    if (fer?.code === 'ENOTEMPTY') {\n      return rimrafMoveRemoveSync(path, options)\n    }\n    throw er\n  }\n}\n\nconst START = Symbol('start')\nconst CHILD = Symbol('child')\nconst FINISH = Symbol('finish')\n\nexport const rimrafWindows = async (path: string, opt: RimrafAsyncOptions) => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  try {\n    return await rimrafWindowsDir(path, opt, await lstat(path), START)\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') return true\n    throw er\n  }\n}\n\nexport const rimrafWindowsSync = (path: string, opt: RimrafSyncOptions) => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  try {\n    return rimrafWindowsDirSync(path, opt, lstatSync(path), START)\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') return true\n    throw er\n  }\n}\n\nconst rimrafWindowsDir = async (\n  path: string,\n  opt: RimrafAsyncOptions,\n  ent: Dirent | Stats,\n  state = START\n): Promise<boolean> => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n\n  const entries = ent.isDirectory() ? await readdirOrError(path) : null\n  if (!Array.isArray(entries)) {\n    // this can only happen if lstat/readdir lied, or if the dir was\n    // swapped out with a file at just the right moment.\n    /* c8 ignore start */\n    if (entries) {\n      if (entries.code === 'ENOENT') {\n        return true\n      }\n      if (entries.code !== 'ENOTDIR') {\n        throw entries\n      }\n    }\n    /* c8 ignore stop */\n    if (opt.filter && !(await opt.filter(path, ent))) {\n      return false\n    }\n    // is a file\n    await ignoreENOENT(rimrafWindowsFile(path, opt))\n    return true\n  }\n\n  const s = state === START ? CHILD : state\n  const removedAll = (\n    await Promise.all(\n      entries.map(ent => rimrafWindowsDir(resolve(path, ent.name), opt, ent, s))\n    )\n  ).reduce((a, b) => a && b, true)\n\n  if (state === START) {\n    return rimrafWindowsDir(path, opt, ent, FINISH)\n  } else if (state === FINISH) {\n    if (opt.preserveRoot === false && path === parse(path).root) {\n      return false\n    }\n    if (!removedAll) {\n      return false\n    }\n    if (opt.filter && !(await opt.filter(path, ent))) {\n      return false\n    }\n    await ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path, opt))\n  }\n  return true\n}\n\nconst rimrafWindowsDirSync = (\n  path: string,\n  opt: RimrafSyncOptions,\n  ent: Dirent | Stats,\n  state = START\n): boolean => {\n  const entries = ent.isDirectory() ? readdirOrErrorSync(path) : null\n  if (!Array.isArray(entries)) {\n    // this can only happen if lstat/readdir lied, or if the dir was\n    // swapped out with a file at just the right moment.\n    /* c8 ignore start */\n    if (entries) {\n      if (entries.code === 'ENOENT') {\n        return true\n      }\n      if (entries.code !== 'ENOTDIR') {\n        throw entries\n      }\n    }\n    /* c8 ignore stop */\n    if (opt.filter && !opt.filter(path, ent)) {\n      return false\n    }\n    // is a file\n    ignoreENOENTSync(() => rimrafWindowsFileSync(path, opt))\n    return true\n  }\n\n  let removedAll = true\n  for (const ent of entries) {\n    const s = state === START ? CHILD : state\n    const p = resolve(path, ent.name)\n    removedAll = rimrafWindowsDirSync(p, opt, ent, s) && removedAll\n  }\n\n  if (state === START) {\n    return rimrafWindowsDirSync(path, opt, ent, FINISH)\n  } else if (state === FINISH) {\n    if (opt.preserveRoot === false && path === parse(path).root) {\n      return false\n    }\n    if (!removedAll) {\n      return false\n    }\n    if (opt.filter && !opt.filter(path, ent)) {\n      return false\n    }\n    ignoreENOENTSync(() => {\n      rimrafWindowsDirMoveRemoveFallbackSync(path, opt)\n    })\n  }\n  return true\n}\n","import { chmodSync, promises } from './fs.js'\nconst { chmod } = promises\n\nexport const fixEPERM =\n  (fn: (path: string) => Promise<any>) => async (path: string) => {\n    try {\n      return await fn(path)\n    } catch (er) {\n      const fer = er as NodeJS.ErrnoException\n      if (fer?.code === 'ENOENT') {\n        return\n      }\n      if (fer?.code === 'EPERM') {\n        try {\n          await chmod(path, 0o666)\n        } catch (er2) {\n          const fer2 = er2 as NodeJS.ErrnoException\n          if (fer2?.code === 'ENOENT') {\n            return\n          }\n          throw er\n        }\n        return await fn(path)\n      }\n      throw er\n    }\n  }\n\nexport const fixEPERMSync = (fn: (path: string) => any) => (path: string) => {\n  try {\n    return fn(path)\n  } catch (er) {\n    const fer = er as NodeJS.ErrnoException\n    if (fer?.code === 'ENOENT') {\n      return\n    }\n    if (fer?.code === 'EPERM') {\n      try {\n        chmodSync(path, 0o666)\n      } catch (er2) {\n        const fer2 = er2 as NodeJS.ErrnoException\n        if (fer2?.code === 'ENOENT') {\n          return\n        }\n        throw er\n      }\n      return fn(path)\n    }\n    throw er\n  }\n}\n","// note: max backoff is the maximum that any *single* backoff will do\n\nimport { RimrafAsyncOptions, RimrafOptions } from './index.js'\n\nexport const MAXBACKOFF = 200\nexport const RATE = 1.2\nexport const MAXRETRIES = 10\nexport const codes = new Set(['EMFILE', 'ENFILE', 'EBUSY'])\n\nexport const retryBusy = (fn: (path: string) => Promise<any>) => {\n  const method = async (\n    path: string,\n    opt: RimrafAsyncOptions,\n    backoff = 1,\n    total = 0\n  ) => {\n    const mbo = opt.maxBackoff || MAXBACKOFF\n    const rate = opt.backoff || RATE\n    const max = opt.maxRetries || MAXRETRIES\n    let retries = 0\n    while (true) {\n      try {\n        return await fn(path)\n      } catch (er) {\n        const fer = er as NodeJS.ErrnoException\n        if (fer?.path === path && fer?.code && codes.has(fer.code)) {\n          backoff = Math.ceil(backoff * rate)\n          total = backoff + total\n          if (total < mbo) {\n            return new Promise((res, rej) => {\n              setTimeout(() => {\n                method(path, opt, backoff, total).then(res, rej)\n              }, backoff)\n            })\n          }\n          if (retries < max) {\n            retries++\n            continue\n          }\n        }\n        throw er\n      }\n    }\n  }\n\n  return method\n}\n\n// just retries, no async so no backoff\nexport const retryBusySync = (fn: (path: string) => any) => {\n  const method = (path: string, opt: RimrafOptions) => {\n    const max = opt.maxRetries || MAXRETRIES\n    let retries = 0\n    while (true) {\n      try {\n        return fn(path)\n      } catch (er) {\n        const fer = er as NodeJS.ErrnoException\n        if (\n          fer?.path === path &&\n          fer?.code &&\n          codes.has(fer.code) &&\n          retries < max\n        ) {\n          retries++\n          continue\n        }\n        throw er\n      }\n    }\n  }\n  return method\n}\n","// https://youtu.be/uhRWMGBjlO8?t=537\n//\n// 1. readdir\n// 2. for each entry\n//   a. if a non-empty directory, recurse\n//   b. if an empty directory, move to random hidden file name in $TEMP\n//   c. unlink/rmdir $TEMP\n//\n// This works around the fact that unlink/rmdir is non-atomic and takes\n// a non-deterministic amount of time to complete.\n//\n// However, it is HELLA SLOW, like 2-10x slower than a naive recursive rm.\n\nimport { basename, parse, resolve } from 'path'\nimport { defaultTmp, defaultTmpSync } from './default-tmp.js'\n\nimport { ignoreENOENT, ignoreENOENTSync } from './ignore-enoent.js'\n\nimport {\n  chmodSync,\n  lstatSync,\n  promises as fsPromises,\n  renameSync,\n  rmdirSync,\n  unlinkSync,\n} from './fs.js'\nconst { lstat, rename, unlink, rmdir, chmod } = fsPromises\n\nimport { Dirent, Stats } from 'fs'\nimport { RimrafAsyncOptions, RimrafSyncOptions } from './index.js'\nimport { readdirOrError, readdirOrErrorSync } from './readdir-or-error.js'\n\n// crypto.randomBytes is much slower, and Math.random() is enough here\nconst uniqueFilename = (path: string) => `.${basename(path)}.${Math.random()}`\n\nconst unlinkFixEPERM = async (path: string) =>\n  unlink(path).catch((er: Error & { code?: string }) => {\n    if (er.code === 'EPERM') {\n      return chmod(path, 0o666).then(\n        () => unlink(path),\n        er2 => {\n          if (er2.code === 'ENOENT') {\n            return\n          }\n          throw er\n        }\n      )\n    } else if (er.code === 'ENOENT') {\n      return\n    }\n    throw er\n  })\n\nconst unlinkFixEPERMSync = (path: string) => {\n  try {\n    unlinkSync(path)\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'EPERM') {\n      try {\n        return chmodSync(path, 0o666)\n      } catch (er2) {\n        if ((er2 as NodeJS.ErrnoException)?.code === 'ENOENT') {\n          return\n        }\n        throw er\n      }\n    } else if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') {\n      return\n    }\n    throw er\n  }\n}\n\nexport const rimrafMoveRemove = async (\n  path: string,\n  opt: RimrafAsyncOptions\n) => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  try {\n    return await rimrafMoveRemoveDir(path, opt, await lstat(path))\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') return true\n    throw er\n  }\n}\n\nconst rimrafMoveRemoveDir = async (\n  path: string,\n  opt: RimrafAsyncOptions,\n  ent: Dirent | Stats\n): Promise<boolean> => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  if (!opt.tmp) {\n    return rimrafMoveRemoveDir(\n      path,\n      { ...opt, tmp: await defaultTmp(path) },\n      ent\n    )\n  }\n  if (path === opt.tmp && parse(path).root !== path) {\n    throw new Error('cannot delete temp directory used for deletion')\n  }\n\n  const entries = ent.isDirectory() ? await readdirOrError(path) : null\n  if (!Array.isArray(entries)) {\n    // this can only happen if lstat/readdir lied, or if the dir was\n    // swapped out with a file at just the right moment.\n    /* c8 ignore start */\n    if (entries) {\n      if (entries.code === 'ENOENT') {\n        return true\n      }\n      if (entries.code !== 'ENOTDIR') {\n        throw entries\n      }\n    }\n    /* c8 ignore stop */\n    if (opt.filter && !(await opt.filter(path, ent))) {\n      return false\n    }\n    await ignoreENOENT(tmpUnlink(path, opt.tmp, unlinkFixEPERM))\n    return true\n  }\n\n  const removedAll = (\n    await Promise.all(\n      entries.map(ent => rimrafMoveRemoveDir(resolve(path, ent.name), opt, ent))\n    )\n  ).reduce((a, b) => a && b, true)\n  if (!removedAll) {\n    return false\n  }\n\n  // we don't ever ACTUALLY try to unlink /, because that can never work\n  // but when preserveRoot is false, we could be operating on it.\n  // No need to check if preserveRoot is not false.\n  if (opt.preserveRoot === false && path === parse(path).root) {\n    return false\n  }\n  if (opt.filter && !(await opt.filter(path, ent))) {\n    return false\n  }\n  await ignoreENOENT(tmpUnlink(path, opt.tmp, rmdir))\n  return true\n}\n\nconst tmpUnlink = async (\n  path: string,\n  tmp: string,\n  rm: (p: string) => Promise<any>\n) => {\n  const tmpFile = resolve(tmp, uniqueFilename(path))\n  await rename(path, tmpFile)\n  return await rm(tmpFile)\n}\n\nexport const rimrafMoveRemoveSync = (path: string, opt: RimrafSyncOptions) => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  try {\n    return rimrafMoveRemoveDirSync(path, opt, lstatSync(path))\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') return true\n    throw er\n  }\n}\n\nconst rimrafMoveRemoveDirSync = (\n  path: string,\n  opt: RimrafSyncOptions,\n  ent: Dirent | Stats\n): boolean => {\n  if (opt?.signal?.aborted) {\n    throw opt.signal.reason\n  }\n  if (!opt.tmp) {\n    return rimrafMoveRemoveDirSync(\n      path,\n      { ...opt, tmp: defaultTmpSync(path) },\n      ent\n    )\n  }\n  const tmp: string = opt.tmp\n\n  if (path === opt.tmp && parse(path).root !== path) {\n    throw new Error('cannot delete temp directory used for deletion')\n  }\n\n  const entries = ent.isDirectory() ? readdirOrErrorSync(path) : null\n  if (!Array.isArray(entries)) {\n    // this can only happen if lstat/readdir lied, or if the dir was\n    // swapped out with a file at just the right moment.\n    /* c8 ignore start */\n    if (entries) {\n      if (entries.code === 'ENOENT') {\n        return true\n      }\n      if (entries.code !== 'ENOTDIR') {\n        throw entries\n      }\n    }\n    /* c8 ignore stop */\n    if (opt.filter && !opt.filter(path, ent)) {\n      return false\n    }\n    ignoreENOENTSync(() => tmpUnlinkSync(path, tmp, unlinkFixEPERMSync))\n    return true\n  }\n\n  let removedAll = true\n  for (const ent of entries) {\n    const p = resolve(path, ent.name)\n    removedAll = rimrafMoveRemoveDirSync(p, opt, ent) && removedAll\n  }\n  if (!removedAll) {\n    return false\n  }\n  if (opt.preserveRoot === false && path === parse(path).root) {\n    return false\n  }\n  if (opt.filter && !opt.filter(path, ent)) {\n    return false\n  }\n  ignoreENOENTSync(() => tmpUnlinkSync(path, tmp, rmdirSync))\n  return true\n}\n\nconst tmpUnlinkSync = (\n  path: string,\n  tmp: string,\n  rmSync: (p: string) => void\n) => {\n  const tmpFile = resolve(tmp, uniqueFilename(path))\n  renameSync(path, tmpFile)\n  return rmSync(tmpFile)\n}\n","// The default temporary folder location for use in the windows algorithm.\n// It's TEMPting to use dirname(path), since that's guaranteed to be on the\n// same device.  However, this means that:\n// rimraf(path).then(() => rimraf(dirname(path)))\n// will often fail with EBUSY, because the parent dir contains\n// marked-for-deletion directory entries (which do not show up in readdir).\n// The approach here is to use os.tmpdir() if it's on the same drive letter,\n// or resolve(path, '\\\\temp') if it exists, or the root of the drive if not.\n// On Posix (not that you'd be likely to use the windows algorithm there),\n// it uses os.tmpdir() always.\nimport { tmpdir } from 'os'\nimport { parse, resolve } from 'path'\nimport { promises, statSync } from './fs.js'\nimport platform from './platform.js'\nconst { stat } = promises\n\nconst isDirSync = (path: string) => {\n  try {\n    return statSync(path).isDirectory()\n  } catch (er) {\n    return false\n  }\n}\n\nconst isDir = (path: string) =>\n  stat(path).then(\n    st => st.isDirectory(),\n    () => false\n  )\n\nconst win32DefaultTmp = async (path: string) => {\n  const { root } = parse(path)\n  const tmp = tmpdir()\n  const { root: tmpRoot } = parse(tmp)\n  if (root.toLowerCase() === tmpRoot.toLowerCase()) {\n    return tmp\n  }\n\n  const driveTmp = resolve(root, '/temp')\n  if (await isDir(driveTmp)) {\n    return driveTmp\n  }\n\n  return root\n}\n\nconst win32DefaultTmpSync = (path: string) => {\n  const { root } = parse(path)\n  const tmp = tmpdir()\n  const { root: tmpRoot } = parse(tmp)\n  if (root.toLowerCase() === tmpRoot.toLowerCase()) {\n    return tmp\n  }\n\n  const driveTmp = resolve(root, '/temp')\n  if (isDirSync(driveTmp)) {\n    return driveTmp\n  }\n\n  return root\n}\n\nconst posixDefaultTmp = async () => tmpdir()\nconst posixDefaultTmpSync = () => tmpdir()\n\nexport const defaultTmp =\n  platform === 'win32' ? win32DefaultTmp : posixDefaultTmp\nexport const defaultTmpSync =\n  platform === 'win32' ? win32DefaultTmpSync : posixDefaultTmpSync\n","import platform from './platform.js'\n\nimport { rimrafPosix, rimrafPosixSync } from './rimraf-posix.js'\nimport { rimrafWindows, rimrafWindowsSync } from './rimraf-windows.js'\n\nexport const rimrafManual = platform === 'win32' ? rimrafWindows : rimrafPosix\nexport const rimrafManualSync =\n  platform === 'win32' ? rimrafWindowsSync : rimrafPosixSync\n","import { RimrafAsyncOptions, RimrafSyncOptions } from './index.js'\nimport { promises, rmSync } from './fs.js'\nconst { rm } = promises\n\nexport const rimrafNative = async (\n  path: string,\n  opt: RimrafAsyncOptions\n): Promise<boolean> => {\n  await rm(path, {\n    ...opt,\n    force: true,\n    recursive: true,\n  })\n  return true\n}\n\nexport const rimrafNativeSync = (\n  path: string,\n  opt: RimrafSyncOptions\n): boolean => {\n  rmSync(path, {\n    ...opt,\n    force: true,\n    recursive: true,\n  })\n  return true\n}\n","import { RimrafAsyncOptions, RimrafOptions } from './index.js'\nimport platform from './platform.js'\n\nconst version = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\n\n/* c8 ignore start */\nconst [major = 0, minor = 0] = versArr.map(v => parseInt(v, 10))\n/* c8 ignore stop */\nconst hasNative = major > 14 || (major === 14 && minor >= 14)\n\n// we do NOT use native by default on Windows, because Node's native\n// rm implementation is less advanced.  Change this code if that changes.\nexport const useNative: (opt?: RimrafAsyncOptions) => boolean =\n  !hasNative || platform === 'win32'\n    ? () => false\n    : opt => !opt?.signal && !opt?.filter\nexport const useNativeSync: (opt?: RimrafOptions) => boolean =\n  !hasNative || platform === 'win32'\n    ? () => false\n    : opt => !opt?.signal && !opt?.filter\n","import { type RimrafAsyncOptions, rimraf } from 'rimraf'\n\n/**\n * Sometimes the browser is still closing when we remove the context directory which results in an error/unwanted behaviour.\n * We retry a few times to make sure it's removed.\n */\nconst opts: RimrafAsyncOptions = {\n  maxRetries: 10\n}\n\n/**\n * Removes the temporary context directory created per-worker basis.\n *\n * This function mirrors the one found in the Playwright source code:\n * https://github.com/microsoft/playwright/blob/d1d5fc67dc684a5d4b682749e59bba8cc0ad14de/packages/playwright-core/src/utils/processLauncher.ts#L142\n */\nexport async function removeTempContextDir(contextDirPath: string) {\n  return new Promise<null | Error>((resolve) => {\n    rimraf(contextDirPath, opts)\n      .then(() => resolve(null))\n      .catch((e: Error) => resolve(e))\n  })\n}\n","import { downloadFile, ensureCacheDirExists, unzipArchive } from '.'\n\nexport const DEFAULT_METAMASK_VERSION = '13.13.1'\nexport const EXTENSION_DOWNLOAD_URL = `https://github.com/MetaMask/metamask-extension/releases/download/v${DEFAULT_METAMASK_VERSION}/metamask-chrome-${DEFAULT_METAMASK_VERSION}.zip`\n\n// NOTE: This function is copied from `wallets/metamask/src/prepareExtension.ts` only TEMPORARILY!\nexport async function prepareExtension() {\n  const cacheDirPath = ensureCacheDirExists()\n\n  const downloadResult = await downloadFile({\n    url: EXTENSION_DOWNLOAD_URL,\n    outputDir: cacheDirPath,\n    fileName: `metamask-chrome-${DEFAULT_METAMASK_VERSION}.zip`\n  })\n\n  const unzipResult = await unzipArchive({\n    archivePath: downloadResult.filePath\n  })\n\n  return unzipResult.outputPath\n}\n","import fs from 'node:fs'\nimport os from 'node:os'\nimport path from 'node:path'\nimport chalk from 'chalk'\nimport { Command } from 'commander'\nimport { rimraf } from 'rimraf'\nimport { WALLET_SETUP_DIR_NAME } from '../constants'\nimport { createCache } from '../createCache'\nimport { prepareExtension } from '../prepareExtension'\nimport { prepareExtensionPhantom } from '../prepareExtensionPhantom'\nimport { compileWalletSetupFunctions } from './compileWalletSetupFunctions'\nimport { footer } from './footer'\n\ninterface CliFlags {\n  headless: boolean\n  force: boolean\n  debug: boolean\n  phantom: boolean\n}\n\n// Helper function to check if running in WSL\nconst isRunningInWsl = (): boolean => {\n  try {\n    const releaseContent = fs.readFileSync('/proc/version', 'utf8').toLowerCase()\n    return releaseContent.includes('microsoft') || releaseContent.includes('wsl')\n  } catch (error) {\n    return false\n  }\n}\n\n// TODO: Add unit tests for the CLI!\nexport const cliEntrypoint = async () => {\n  console.log(`âš ï¸ ${chalk.yellowBright`The CLI is in alpha so expect breaking changes!`} âš ï¸\\n`)\n\n  const program = new Command()\n    .name(chalk.magenta('synpress'))\n    .description('A CLI for building the cache of wallet setup functions')\n    .argument('[dir]', 'Directory containing the wallet setup functions', path.join('test', WALLET_SETUP_DIR_NAME))\n    .option(\n      '--headless',\n      'Build cache in the headless browser mode. Alternatively, set the `HEADLESS` env variable to `true`',\n      false\n    )\n    .option('-f, --force', 'Force the creation of cache even if it already exists', false)\n    .option('-d, --debug', 'If this flag is present, the compilation files are not going to be deleted', false)\n    .option('-p, --phantom', 'If this flag is present, Phantom extension will be installed instead of Metamask', false)\n    .helpOption(undefined, 'Display help for command')\n    .addHelpText('afterAll', `\\n${footer}\\n`)\n    .parse(process.argv)\n\n  let walletSetupDir = path.join(process.cwd(), 'test', WALLET_SETUP_DIR_NAME)\n\n  if (program.args[0]) {\n    walletSetupDir = path.join(process.cwd(), program.args[0])\n  }\n\n  const flags: CliFlags = program.opts()\n\n  if (flags.headless) {\n    process.env.HEADLESS = true\n  }\n\n  if (flags.debug) {\n    console.log('[DEBUG] Running with the following options:')\n    console.log(\n      {\n        cacheDir: walletSetupDir,\n        ...flags,\n        headless: Boolean(process.env.HEADLESS) ?? false\n      },\n      '\\n'\n    )\n  }\n\n  if (os.platform() === 'win32' && !isRunningInWsl()) {\n    console.log(\n      [\n        chalk.redBright('ðŸš¨ Sorry, Windows is currently not supported. Please use WSL instead! ðŸš¨'),\n        chalk.gray(\n          'If you want to give it a crack over a hot cup of coffee and add Windows support yourself, please get in touch with the team on Discord so we can offer some guidance! ðŸ˜‡'\n        )\n      ].join('\\n')\n    )\n    process.exit(1)\n  }\n\n  console.log(chalk.greenBright('ðŸš€ Building the cache for wallet setup functions... ðŸš€\\n'))\n\n  const { outDir: compiledWalletSetupDirPath, setupFunctionHashes } = await compileWalletSetupFunctions(\n    walletSetupDir,\n    flags.debug\n  )\n\n  // TODO: We should be using `prepareExtension` functions from the wallet itself!\n  if (flags.phantom) {\n    await createCache(compiledWalletSetupDirPath, setupFunctionHashes, prepareExtensionPhantom, flags.force)\n  } else {\n    await createCache(compiledWalletSetupDirPath, setupFunctionHashes, prepareExtension, flags.force)\n  }\n\n  if (!flags.debug) {\n    await rimraf(compiledWalletSetupDirPath)\n  }\n}\n","import { downloadFile, ensureCacheDirExists, unzipArchivePhantom } from '.'\n\nexport const PHANTOM_EXTENSION_DOWNLOAD_URL = 'https://crx-backup.phantom.dev/latest.crx'\n\n// NOTE: This function is copied from `wallets/phantom/src/prepareExtensionPhantom.ts` only TEMPORARILY!\nexport async function prepareExtensionPhantom() {\n  const cacheDirPath = ensureCacheDirExists()\n\n  const downloadResult = await downloadFile({\n    url: PHANTOM_EXTENSION_DOWNLOAD_URL,\n    outputDir: cacheDirPath,\n    fileName: 'phantom-chrome-latest.crx'\n  })\n\n  const unzipResult = await unzipArchivePhantom({\n    archivePath: downloadResult.filePath\n  })\n\n  return unzipResult.outputPath\n}\n","import path from 'node:path'\nimport fs from 'fs-extra'\nimport { glob } from 'glob'\nimport { build } from 'tsup'\n\nimport { ensureCacheDirExists } from '../ensureCacheDirExists'\nimport buildWalletSetupFunction from '../utils/buildWalletSetupFunction'\nimport { extractWalletSetupFunction } from '../utils/extractWalletSetupFunction'\nimport { getWalletSetupFuncHash } from '../utils/getWalletSetupFuncHash'\nimport { FIXES_BANNER } from './compilationFixes'\n\nconst OUT_DIR_NAME = '.wallet-setup-dist'\n\nconst createGlobPattern = (walletSetupDir: string) => path.join(walletSetupDir, '**', '*.setup.{ts,js,mjs}')\n\nexport async function compileWalletSetupFunctions(walletSetupDir: string, debug: boolean) {\n  const outDir = path.join(ensureCacheDirExists(), OUT_DIR_NAME)\n\n  fs.ensureDirSync(outDir)\n\n  const globPattern = createGlobPattern(walletSetupDir)\n  const fileList = (await glob(globPattern)).sort()\n\n  if (debug) {\n    console.log('[DEBUG] Found the following wallet setup files:')\n    console.log(fileList, '\\n')\n  }\n\n  // TODO: This error message is copied over from another function. Refactor this.\n  if (!fileList.length) {\n    throw new Error(\n      [\n        `No wallet setup files found at ${walletSetupDir}`,\n        'Remember that all wallet setup files must end with `.setup.{ts,js,mjs}` extension!'\n      ].join('\\n')\n    )\n  }\n\n  await build({\n    name: 'cli-build',\n    silent: true,\n    entry: fileList,\n    clean: true,\n    outDir,\n    format: 'esm',\n    splitting: true,\n    sourcemap: false,\n    config: false,\n    // TODO: Make this list configurable.\n    external: ['@synthetixio/synpress', '@playwright/test', 'playwright-core', 'esbuild', 'tsup'],\n    banner: {\n      js: FIXES_BANNER\n    },\n    esbuildOptions(options) {\n      // TODO: In this step, if the debug file is present, we should modify `console.log` so it prints from which file the log is coming from.\n      // We're dropping `console.log` and `debugger` statements because they do not play nicely with the Playwright Test Runner.\n      options.drop = debug ? [] : ['console', 'debugger']\n    }\n  })\n\n  const setupFunctionHashes = await Promise.all(\n    fileList.map(async (filePath) => {\n      const sourceCode = fs.readFileSync(filePath, 'utf8')\n      const functionString = extractWalletSetupFunction(sourceCode)\n\n      const rawFunctionBuild = buildWalletSetupFunction(functionString)\n\n      return getWalletSetupFuncHash(rawFunctionBuild)\n    })\n  )\n\n  return { outDir, setupFunctionHashes }\n}\n","export function extractWalletSetupFunction(sourceCode: string): string {\n  const match = sourceCode.match(\n    /defineWalletSetup\\s*\\([^,]*,\\s*(async\\s*\\([^)]*\\)\\s*=>\\s*{(?:[^{}]*|{(?:[^{}]*|{[^{}]*})*})*})\\s*\\)/\n  )\n\n  if (!match || !match[1]) {\n    console.log('Failed to extract defineWalletSetup callback from:', sourceCode)\n    throw new Error('Could not find defineWalletSetup callback')\n  }\n\n  return match[1]\n}\n","// Fixes -> Error: Dynamic require of \"fs\" is not supported\n// Issue link: https://github.com/evanw/esbuild/issues/1921\nconst DYNAMIC_REQUIRE_FS_FIX = `\n// ---- DYNAMIC_REQUIRE_FS_FIX ----\nvar require = (await import(\"node:module\")).createRequire(import.meta.url);\nvar __filename = (await import(\"node:url\")).fileURLToPath(import.meta.url);\nvar __dirname = (await import(\"node:path\")).dirname(__filename);\n// ---- DYNAMIC_REQUIRE_FS_FIX ----\n`.trim()\n\nexport const FIXES_BANNER = `\n/// ######## BANNER WITH FIXES START ########\n\n${DYNAMIC_REQUIRE_FS_FIX}\n\n/// ######## BANNER WITH FIXES END ########\n`.trimStart()\n","import gradient from 'gradient-string'\n\nconst footerText = 'Made with love by the Synpress team ðŸ’œ'\n\nexport const footer = gradient('magenta', 'cyan')(footerText)\n"]}