import { errors, test, chromium, expect } from '@playwright/test';
import { z } from 'zod';
import path from 'path';
import { CACHE_DIR_NAME, createTempContextDir, removeTempContextDir, ensureCacheDirExists, downloadFile, unzipArchivePhantom } from '@synthetixio/synpress-cache';
import fs from 'fs-extra';

// src/type/PhantomAbstract.ts
var PhantomAbstract = class {
  /**
   * @param password - The password of the Phantom wallet.
   * @param extensionId - The extension ID of the Phantom extension. Optional if no interaction with the dapp is required.
   *
   * @returns A new instance of the Phantom class.
   */
  constructor(password, extensionId) {
    this.password = password;
    this.extensionId = extensionId;
    this.password = password;
    this.extensionId = extensionId;
  }
};

// src/selectors/pages/OnboardingPage/getStartedPage.ts
var getStartedPage_default = {
  importWallet: "text=I already have a wallet",
  importRecoveryPhraseButton: "text=Import Recovery Phrase"
};

// src/selectors/createDataTestSelector.ts
var createDataTestSelector = (dataTestId) => {
  if (dataTestId.includes(" ")) {
    throw new Error("[CreateDataTestSelector] dataTestId cannot contain spaces");
  }
  return `[data-testid="${dataTestId}"]`;
};

// src/selectors/pages/OnboardingPage/secretRecoveryPhrasePage.ts
var recoveryStep = {
  secretRecoveryPhraseWord: (index) => createDataTestSelector(`secret-recovery-phrase-word-input-${index}`),
  confirmSecretRecoveryPhraseButton: createDataTestSelector("onboarding-form-submit-button"),
  error: createDataTestSelector("onboarding-import-secret-recovery-phrase-error-message")
};
var viewAccountsButton = createDataTestSelector("onboarding-form-secondary-button");
var continueButton = createDataTestSelector("onboarding-form-submit-button");
var passwordStep = {
  passwordInput: createDataTestSelector("onboarding-form-password-input"),
  confirmPasswordInput: createDataTestSelector("onboarding-form-confirm-password-input"),
  acceptTermsCheckbox: createDataTestSelector("onboarding-form-terms-of-service-checkbox"),
  continue: continueButton,
  error: `${createDataTestSelector("create-password-new")} + h6 > span > span`
};
var allDone = `text=You're all ready!`;
var secretRecoveryPhrasePage_default = {
  recoveryStep,
  viewAccountsButton,
  continueButton,
  passwordStep,
  allDone
};

// src/selectors/pages/OnboardingPage/walletCreationSuccessPage.ts
var walletCreationSuccessPage_default = {
  confirmButton: createDataTestSelector("onboarding-complete-done")
};

// src/selectors/pages/OnboardingPage/index.ts
var OnboardingPage_default = {
  GetStartedPageSelectors: getStartedPage_default,
  SecretRecoveryPhrasePageSelectors: secretRecoveryPhrasePage_default,
  WalletCreationSuccessPageSelectors: walletCreationSuccessPage_default
};

// src/playwright/pages/OnboardingPage/actions/helpers/confirmSecretRecoveryPhrase.ts
var StepSelectors = OnboardingPage_default.SecretRecoveryPhrasePageSelectors.recoveryStep;
async function confirmSecretRecoveryPhrase(page, seedPhrase) {
  const seedPhraseWords = seedPhrase.split(" ");
  for (const [index, word] of seedPhraseWords.entries()) {
    await page.locator(StepSelectors.secretRecoveryPhraseWord(index)).fill(word);
  }
  await page.locator(StepSelectors.confirmSecretRecoveryPhraseButton).click();
  if (await page.locator(StepSelectors.error).isVisible({ timeout: 2e3 })) {
    const errorText = await page.locator(StepSelectors.error).textContent({
      timeout: 1e3
    });
    throw new Error(`[ConfirmSecretRecoveryPhrase] Invalid seed phrase. Error from Phantom: ${errorText}`);
  }
}

// src/playwright/pages/OnboardingPage/actions/helpers/createPassword.ts
var StepSelectors2 = OnboardingPage_default.SecretRecoveryPhrasePageSelectors.passwordStep;
async function createPassword(page, password) {
  await page.locator(StepSelectors2.passwordInput).fill(password);
  await page.locator(StepSelectors2.confirmPasswordInput).fill(password);
  await page.locator(StepSelectors2.acceptTermsCheckbox).click();
  await page.locator(StepSelectors2.continue).click();
}

// src/playwright/pages/OnboardingPage/actions/importWallet.ts
async function importWallet(page, seedPhrase, password) {
  await page.locator(OnboardingPage_default.GetStartedPageSelectors.importWallet).click();
  await page.locator(OnboardingPage_default.GetStartedPageSelectors.importRecoveryPhraseButton).click();
  await confirmSecretRecoveryPhrase(page, seedPhrase);
  await expect(
    page.locator(OnboardingPage_default.SecretRecoveryPhrasePageSelectors.viewAccountsButton),
    "Import accounts success screen should be visible"
  ).toBeVisible({ timeout: 6e4 });
  await page.locator(OnboardingPage_default.SecretRecoveryPhrasePageSelectors.continueButton).click();
  await createPassword(page, password);
  await expect(
    page.locator(OnboardingPage_default.SecretRecoveryPhrasePageSelectors.allDone),
    "All Done success screen should be visible"
  ).toBeVisible({ timeout: 1e4 });
}

// src/playwright/pages/OnboardingPage/page.ts
var OnboardingPage = class {
  static selectors = OnboardingPage_default;
  selectors = OnboardingPage_default;
  page;
  constructor(page) {
    this.page = page;
  }
  async importWallet(seedPhrase, password) {
    return await importWallet(this.page, seedPhrase, password);
  }
};

// src/selectors/pages/UnlockPage/index.ts
var UnlockPage_default = {
  passwordInput: createDataTestSelector("unlock-form-password-input"),
  submitButton: createDataTestSelector("unlock-form-submit-button")
};

// src/selectors/loading/index.ts
var LoadingSelectors = {
  spinner: ".spinner"};

// src/selectors/pages/HomePage/settings.ts
var devSettings = {
  toggleTestnetMode: createDataTestSelector("toggleTestNetwork"),
  toggleEnableCopyTransaction: createDataTestSelector("solana-copy-transaction")
};
var securityAndPrivacy = {
  resetApp: 'button:has-text("Reset App")'
};
var settings_default = {
  securityAndPrivacyButton: createDataTestSelector("settings-item-security-and-privacy"),
  lockWallet: createDataTestSelector("lock-menu-item"),
  unlocWallet: createDataTestSelector('data-testid="unlock-form-submit-button"'),
  developerSettingsButton: 'button:has-text("Developer Settings")',
  closeSettingsButton: createDataTestSelector("settings-menu-close-button"),
  devSettings,
  securityAndPrivacy
};

// src/selectors/pages/HomePage/index.ts
var addNewAccountMenu = {
  accountNameInput: `input[placeholder="Name"]`,
  createButton: `button${createDataTestSelector("primary-button")}:has-text("Create")`
};
var renameAccountMenu = {
  saveButton: `button${createDataTestSelector("primary-button")}:has-text("Save")`
};
var importAccountMenu = {
  networkOpenMenu: '[aria-haspopup="listbox"][role="button"]:has-text("Solana")',
  ethereumNetwork: '[data-label="Ethereum"]',
  baseNetwork: '[data-label="Base"]',
  polygonNetwork: '[data-label="Polygon"]',
  bitcoinNetwork: '[data-label="Bitcoin"]',
  nameInput: 'input[name="name"]',
  privateKeyInput: 'textarea[placeholder="Private key"]',
  importButton: 'button:has-text("Import")',
  error: 'textarea[placeholder="Private key"] + div'
};
var addAccountMenu = {
  addAccountButton: createDataTestSelector("sidebar_menu-button-add_account"),
  createNewAccountButton: createDataTestSelector("add-account-create-new-wallet-button"),
  importAccountPrivateKeyButton: "text=Import Private Key",
  addNewAccountMenu,
  importAccountMenu
};
var editAccountMenu = {
  accountNameButton: 'button:has-text("Account Name")'
};
var accountMenu = {
  accountName: createDataTestSelector("home-header-account-name"),
  accountButton: createDataTestSelector("settings-menu-open-button"),
  accountNames: "#accounts button > div:nth-child(2)",
  manageAccountsButton: createDataTestSelector("sidebar_menu-button-manage_accounts"),
  settings: createDataTestSelector("sidebar_menu-button-settings"),
  addAccountMenu,
  renameAccountMenu
};
var manageAccountButton = (accountName) => `[role="button"][data-testid="manage-accounts-sortable-${accountName}"]`;
var HomePage_default = {
  solanaWalletAddress: createDataTestSelector("account-header-chain-solana:101"),
  ethereumWalletAddress: createDataTestSelector("account-header-chain-eip155:1"),
  baseWalletAddress: createDataTestSelector("account-header-chain-eip155:8453"),
  polygonWalletAddress: createDataTestSelector("account-header-chain-eip155:137"),
  bitcoinWalletAddress: createDataTestSelector("account-header-chain-bip122:000000000019d6689c085ae165831e93"),
  copyAccountAddressButton: createDataTestSelector("address-copy-button-text"),
  currentNetwork: `${createDataTestSelector("network-display")} span:nth-of-type(1)`,
  headerBackButton: `section:has-text("Developer Settings") ${createDataTestSelector("header--back")}`,
  settings: settings_default,
  accountMenu,
  editAccountMenu,
  manageAccountButton
};

// src/selectors/pages/NotificationPage/actionFooter.ts
var actionFooter_default = {
  connectActionButton: `button${createDataTestSelector("primary-button")}:has-text("Connect")`,
  confirmActionButton: `button${createDataTestSelector("primary-button")}:has-text("Confirm")`,
  continueActionButton: `button${createDataTestSelector("primary-button")}:has-text("Continue")`,
  cancelActionButton: `button${createDataTestSelector("secondary-button")}:has-text("Cancel")`,
  closeActionButton: createDataTestSelector("button-close")
};

// src/selectors/pages/NotificationPage/signaturePage.ts
var structuredMessage = {
  scrollDownButton: `.signature-request-message ${createDataTestSelector("signature-request-scroll-button")}`
};
var riskModal = {
  proceedAnyway: "text=Proceed anyway (unsafe)",
  confirmUnsafe: "text=Confirm (unsafe)",
  acknowledgeRisks: createDataTestSelector("acknowledge--button"),
  reconfirmUnsafe: "text=Yes, confirm (unsafe)"
};
var signaturePage_default = {
  structuredMessage,
  riskModal
};

// src/selectors/pages/NotificationPage/transactionPage.ts
var editGasFeeMenu = {
  editGasFeeButton: 'button:has-text("Network Fee")',
  slowGasFeeButton: 'div > div p:has-text("Slow")',
  fastGasFeeButton: 'div > div p:has-text("Fast")',
  saveButton: 'button:has-text("Save")'
};
var nftApproveAllConfirmationPopup = {
  approveButton: ".set-approval-for-all-warning__content button.set-approval-for-all-warning__footer__approve-button"
};
var transactionPage_default = {
  editGasFeeMenu,
  nftApproveAllConfirmationPopup
};

// src/selectors/pages/NotificationPage/index.ts
var NotificationPage_default = {
  ActionFooter: actionFooter_default,
  SignaturePage: signaturePage_default,
  TransactionPage: transactionPage_default
};

// src/playwright/utils/waitForSpinnerToVanish.ts
var DEFAULT_TIMEOUT = 1e4;
async function waitForSpinnerToVanish(page) {
  await page.locator(LoadingSelectors.spinner).waitFor({
    state: "hidden",
    timeout: DEFAULT_TIMEOUT
  });
}

// src/playwright/pages/UnlockPage/actions/unlock.ts
async function unlock(page, password) {
  await page.locator(UnlockPage_default.passwordInput).fill(password);
  await page.locator(UnlockPage_default.submitButton).click();
  await waitForSpinnerToVanish(page);
}

// src/playwright/pages/UnlockPage/page.ts
var UnlockPage = class {
  static selectors = UnlockPage_default;
  selectors = UnlockPage_default;
  page;
  constructor(page) {
    this.page = page;
  }
  async unlock(password) {
    await unlock(this.page, password);
  }
};

// src/playwright/pages/HomePage/actions/addNewAccount.ts
async function addNewAccount(page, accountName) {
  if (accountName.length === 0) {
    throw new Error("[AddNewAccount] Account name cannot be an empty string");
  }
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  await page.locator(HomePage_default.accountMenu.addAccountMenu.addAccountButton).click();
  await page.locator(HomePage_default.accountMenu.addAccountMenu.createNewAccountButton).click();
  await page.locator(HomePage_default.accountMenu.addAccountMenu.addNewAccountMenu.accountNameInput).fill(accountName);
  await page.locator(HomePage_default.accountMenu.addAccountMenu.addNewAccountMenu.createButton).click();
}
async function closeSuiAndMonadIfPresent(page) {
  const walletValueUsdRegExp = new RegExp("\\$.*[0-9].[0-9]{1,2}.*[0-9]{1,2}\\%");
  await expect(page.getByText(walletValueUsdRegExp), "Wallet value should be visible").toBeVisible({ timeout: 15e3 });
  await page.reload();
  await expect(page.getByText(walletValueUsdRegExp), "Wallet value should be visible").toBeVisible({ timeout: 15e3 });
  await page.waitForTimeout(2e3);
  const suiIsVisible = await page.getByRole("button", { name: "Enable Sui" }).isVisible();
  if (suiIsVisible) {
    await page.getByRole("button", { name: "Not Now" }).click();
    await page.waitForTimeout(1e3);
  }
  const monadIsVisible = await page.getByRole("button", { name: "Enable Monad" }).isVisible();
  if (monadIsVisible) {
    await page.getByRole("button", { name: "Not Now" }).click();
  }
}
var waitUntilStable = async (page) => {
  await page.waitForLoadState("load", { timeout: 1e4 });
  await page.waitForLoadState("domcontentloaded", { timeout: 1e4 });
};
var waitUntilStableBeforeUnlock = async (page) => {
  await page.waitForLoadState("load", { timeout: 1e4 });
  await page.waitForLoadState("domcontentloaded", { timeout: 1e4 });
  await expect(async () => {
    await expect(page.locator(UnlockPage_default.submitButton), '"Unlock" buttonshouldbe visible').toBeVisible();
  }).toPass({ timeout: 1e4 });
};
var waitUntilStableNotificationPage = async (page) => {
  await page.waitForLoadState("load", { timeout: 1e4 });
  await page.waitForLoadState("domcontentloaded", { timeout: 1e4 });
  await page.locator('[data-testid="home-header-account-name"]').waitFor({ timeout: 1e4 });
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var timeouts = [0, 20, 50, 100, 100, 500];
async function waitFor(action, timeout, shouldThrow = true) {
  let timeoutsSum = 0;
  let timeoutIndex = 0;
  let reachedTimeout = false;
  while (!reachedTimeout) {
    let nextTimeout = timeouts.at(Math.min(timeoutIndex++, timeouts.length - 1));
    if (timeoutsSum + nextTimeout > timeout) {
      nextTimeout = timeout - timeoutsSum;
      reachedTimeout = true;
    } else {
      timeoutsSum += nextTimeout;
    }
    await sleep(nextTimeout);
    const result = await action();
    if (result) {
      return result;
    }
  }
  if (shouldThrow) {
    throw new Error(`Timeout ${timeout}ms exceeded.`);
  }
  return false;
}

// src/playwright/pages/HomePage/actions/importWalletFromPrivateKey.ts
async function importWalletFromPrivateKey(page, network, privateKey, walletName) {
  await expect(page.locator(HomePage_default.accountMenu.accountButton)).toBeVisible();
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  await expect(page.locator(HomePage_default.accountMenu.addAccountMenu.addAccountButton)).toBeVisible();
  await page.locator(HomePage_default.accountMenu.addAccountMenu.addAccountButton).click();
  await page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountPrivateKeyButton).click();
  if (network !== "solana") {
    await page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountMenu.networkOpenMenu).click();
    await page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountMenu[`${network}Network`]).first().click();
  }
  await page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountMenu.nameInput).fill(walletName ?? "ImportedWallet");
  await page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountMenu.privateKeyInput).fill(privateKey);
  const importButton = page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountMenu.importButton);
  const isImportButtonEnabled = await waitFor(() => importButton.isEnabled(), 1e3, false);
  if (!isImportButtonEnabled) {
    const errorText = await page.locator(HomePage_default.accountMenu.addAccountMenu.importAccountMenu.error).textContent({
      timeout: 1e3
      // TODO: Extract & make configurable
    });
    throw new Error(`[ImportWalletFromPrivateKey] Importing failed due to error: ${errorText}`);
  }
  await importButton.click();
  await expect(page.locator('[data-testid*="fungible-token-row-"]').first()).toBeVisible({ timeout: 1e4 });
}

// src/playwright/pages/HomePage/actions/lock.ts
async function lock(page) {
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  await page.locator(HomePage_default.accountMenu.settings).click();
  await page.locator(HomePage_default.settings.lockWallet).click();
}
async function allTextContents(locators) {
  const names = await Promise.all(locators.map((locator) => locator.textContent()));
  return names.map((name) => z.string().parse(name));
}

// src/playwright/pages/HomePage/actions/renameAccount.ts
async function renameAccount(page, currentAccountName, newAccountName) {
  if (newAccountName.length === 0) {
    throw new Error("[RenameAccount] Account name cannot be an empty string");
  }
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  let accountNames = [];
  await expect(async () => {
    const accountNamesLocators = await page.locator(HomePage_default.accountMenu.accountNames).all();
    accountNames = await allTextContents(accountNamesLocators);
    expect(accountNames.length).toBeGreaterThan(0);
  }).toPass();
  const seekedAccountNames = accountNames.filter(
    (name) => name.toLocaleLowerCase() === currentAccountName.toLocaleLowerCase()
  );
  if (seekedAccountNames.length === 0) {
    throw new Error(`[SwitchAccount] Account with name ${currentAccountName} not found`);
  }
  await page.locator(HomePage_default.accountMenu.manageAccountsButton).click();
  await page.locator(HomePage_default.manageAccountButton(currentAccountName)).click();
  await page.locator(HomePage_default.editAccountMenu.accountNameButton).click();
  await page.locator(HomePage_default.accountMenu.addAccountMenu.addNewAccountMenu.accountNameInput).fill(newAccountName);
  await page.locator(HomePage_default.accountMenu.renameAccountMenu.saveButton).click();
  await expect(page.locator(HomePage_default.editAccountMenu.accountNameButton)).toContainText(newAccountName);
}

// src/playwright/pages/HomePage/actions/settings.ts
async function openSettings(page) {
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  await page.locator(HomePage_default.accountMenu.settings).click();
}
async function resetApp(page) {
  await openSettings(page);
  await page.locator(HomePage_default.settings.securityAndPrivacyButton).click();
  await page.waitForSelector(HomePage_default.settings.securityAndPrivacy.resetApp);
  await page.locator(HomePage_default.settings.securityAndPrivacy.resetApp).click();
  await page.locator(NotificationPage_default.ActionFooter.continueActionButton).click();
}
var settings = {
  openSettings,
  resetApp
};
async function switchAccount(page, accountName) {
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  let accountNamesLocators = [];
  let accountNames = [];
  await expect(async () => {
    accountNamesLocators = await page.locator(HomePage_default.accountMenu.accountNames).all();
    accountNames = await allTextContents(accountNamesLocators);
    expect(accountNames.length).toBeGreaterThan(0);
  }).toPass();
  const seekedAccountNames = accountNames.filter((name) => name.toLocaleLowerCase() === accountName.toLocaleLowerCase());
  if (seekedAccountNames.length === 0) {
    throw new Error(`[SwitchAccount] Account with name ${accountName} not found`);
  }
  const accountIndex = accountNames.indexOf(seekedAccountNames[0]);
  await accountNamesLocators[accountIndex].click();
}

// src/playwright/pages/HomePage/actions/toggleTestnetMode.ts
async function toggleTestnetMode(page) {
  await page.locator(HomePage_default.accountMenu.accountButton).click();
  await page.locator(HomePage_default.accountMenu.settings).click();
  await page.locator(HomePage_default.settings.developerSettingsButton).click();
  await page.locator(HomePage_default.settings.devSettings.toggleTestnetMode).click();
}

// src/playwright/pages/HomePage/actions/getAccountAddress.ts
async function getAccountAddress(network, page) {
  await page.locator(HomePage_default.accountMenu.accountName).hover();
  await page.locator(HomePage_default[`${network}WalletAddress`]).first().click();
  const handle = await page.evaluateHandle(() => navigator.clipboard.readText());
  const account = await handle.jsonValue();
  return account;
}

// src/playwright/pages/HomePage/page.ts
var HomePage = class {
  static selectors = HomePage_default;
  selectors = HomePage_default;
  page;
  constructor(page) {
    this.page = page;
  }
  async goToHomePage(extensionId) {
    await this.page.goto(`chrome-extension://${extensionId}/popup.html`);
  }
  async goBackToHomePage() {
    await this.page.locator(HomePage_default.settings.closeSettingsButton).click();
  }
  async lock() {
    await lock(this.page);
  }
  async addNewAccount(accountName) {
    await addNewAccount(this.page, accountName);
  }
  async renameAccount(currentAccountName, newAccountName) {
    await renameAccount(this.page, currentAccountName, newAccountName);
  }
  async getAccountAddress(network) {
    return await getAccountAddress(network, this.page);
  }
  async importWalletFromPrivateKey(network, privateKey, walletName) {
    await importWalletFromPrivateKey(this.page, network, privateKey, walletName);
  }
  async switchAccount(accountName) {
    await switchAccount(this.page, accountName);
  }
  async openSettings() {
    await settings.openSettings(this.page);
  }
  async toggleTestnetMode() {
    await toggleTestnetMode(this.page);
  }
  async resetApp() {
    await settings.resetApp(this.page);
  }
};

// src/playwright/utils/getNotificationPageAndWaitForLoad.ts
async function getNotificationPageAndWaitForLoad(context, extensionId) {
  const notificationPageUrl = `chrome-extension://${extensionId}/notification.html`;
  const isNotificationPage = (page) => page.url().includes(notificationPageUrl);
  let notificationPage = context.pages().find(isNotificationPage);
  if (!notificationPage) {
    notificationPage = await context.waitForEvent("page", {
      predicate: isNotificationPage,
      timeout: 1e4
    });
  }
  await waitUntilStableNotificationPage(notificationPage);
  await notificationPage.setViewportSize({
    width: 360,
    height: 592
  });
  await waitUntilStableNotificationPage(notificationPage);
  return notificationPage;
}
var GasSettingValidation = z.union([
  z.literal("Slow"),
  z.literal("Fast"),
  z.literal("Average"),
  z.object({
    maxBaseFee: z.number(),
    priorityFee: z.number(),
    // TODO: Add gasLimit range validation.
    gasLimit: z.number().optional()
  }).superRefine(({ maxBaseFee, priorityFee }, ctx) => {
    if (priorityFee > maxBaseFee) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Max base fee cannot be lower than priority fee",
        path: ["Phantom", "confirmTransaction", "gasSetting", "maxBaseFee"]
      });
    }
  })
]);

// src/playwright/pages/NotificationPage/actions/transaction.ts
var confirmTransaction = async (notificationPage, options) => {
  const gasSetting = GasSettingValidation.parse(options);
  const handleNftSetApprovalForAll = async (page) => {
    try {
      const nftApproveButtonLocator = page.locator(
        NotificationPage_default.TransactionPage.nftApproveAllConfirmationPopup.approveButton
      );
      const isNfTPopupHidden = await waitFor(() => nftApproveButtonLocator.isHidden(), 3e3, false);
      if (!isNfTPopupHidden) {
        await nftApproveButtonLocator.click();
      }
    } catch (e) {
      if (page.isClosed()) {
        return;
      }
      throw new Error(`Failed to handle NFT setApprovalForAll popup: ${e}`);
    }
  };
  if (gasSetting === "Average") {
    await notificationPage.locator(NotificationPage_default.ActionFooter.confirmActionButton).click();
    await handleNftSetApprovalForAll(notificationPage);
    return;
  }
  await notificationPage.locator(NotificationPage_default.TransactionPage.editGasFeeMenu.editGasFeeButton).click();
  const handleSlowOrFastGasSetting = async (selector) => {
    await notificationPage.locator(selector).click();
  };
  if (gasSetting === "Slow") {
    await handleSlowOrFastGasSetting(NotificationPage_default.TransactionPage.editGasFeeMenu.slowGasFeeButton);
  } else if (gasSetting === "Fast") {
    await handleSlowOrFastGasSetting(NotificationPage_default.TransactionPage.editGasFeeMenu.fastGasFeeButton);
  }
  await notificationPage.locator(NotificationPage_default.TransactionPage.editGasFeeMenu.saveButton).click();
  await notificationPage.locator(NotificationPage_default.ActionFooter.confirmActionButton).click();
  await handleNftSetApprovalForAll(notificationPage);
};
var rejectTransaction = async (notificationPage) => {
  await notificationPage.locator(NotificationPage_default.ActionFooter.cancelActionButton).click();
};
var transaction = {
  confirm: confirmTransaction,
  reject: rejectTransaction
};

// src/playwright/pages/NotificationPage/actions/approvePermission.ts
var approveTokenPermission = async (notificationPage, gasSetting) => {
  await transaction.confirm(notificationPage, gasSetting);
};
var rejectTokenPermission = async (notificationPage) => {
  await notificationPage.locator(NotificationPage_default.ActionFooter.cancelActionButton).click();
};
var approvePermission = {
  approve: approveTokenPermission,
  reject: rejectTokenPermission
};

// src/playwright/pages/NotificationPage/actions/closeUnsupportedNetworkWarning.ts
async function closeWarning(notificationPage) {
  await notificationPage.locator(NotificationPage_default.ActionFooter.closeActionButton).click();
}
async function closeUnsupportedNetworkWarning(notificationPage) {
  await closeWarning(notificationPage);
}

// src/playwright/pages/NotificationPage/actions/connectToDapp.ts
async function confirmConnection(notificationPage) {
  await notificationPage.locator(NotificationPage_default.ActionFooter.connectActionButton).click();
}
async function connectToDapp(notificationPage, account) {
  if (account) {
    await switchAccount(notificationPage, account);
  }
  await confirmConnection(notificationPage);
}

// src/playwright/pages/NotificationPage/actions/signSimpleMessage.ts
var signMessage = async (notificationPage) => {
  await notificationPage.locator(NotificationPage_default.ActionFooter.confirmActionButton).click();
};
var rejectMessage = async (notificationPage) => {
  await notificationPage.locator(NotificationPage_default.ActionFooter.cancelActionButton).click();
};
var signMessageWithRisk = async (notificationPage) => {
  await notificationPage.locator(NotificationPage_default.SignaturePage.riskModal.proceedAnyway).click();
  await notificationPage.locator(NotificationPage_default.SignaturePage.riskModal.confirmUnsafe).click();
  await notificationPage.locator(NotificationPage_default.SignaturePage.riskModal.acknowledgeRisks).click();
  await notificationPage.locator(NotificationPage_default.SignaturePage.riskModal.reconfirmUnsafe).click();
};
var signSimpleMessage = {
  sign: signMessage,
  reject: rejectMessage,
  signWithRisk: signMessageWithRisk
};

// src/playwright/pages/NotificationPage/page.ts
var NotificationPage = class {
  static selectors = NotificationPage_default;
  selectors = NotificationPage_default;
  page;
  constructor(page) {
    this.page = page;
  }
  async connectToDapp(extensionId, account) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await connectToDapp(notificationPage, account);
  }
  // TODO: Revisit this logic in the future to see if we can increase the performance by utilizing `Promise.race`.
  async beforeMessageSignature(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    return {
      notificationPage
    };
  }
  async signMessage(extensionId) {
    const { notificationPage } = await this.beforeMessageSignature(extensionId);
    await signSimpleMessage.sign(notificationPage);
  }
  async signMessageWithRisk(extensionId) {
    const { notificationPage } = await this.beforeMessageSignature(extensionId);
    await signSimpleMessage.signWithRisk(notificationPage);
  }
  async rejectMessage(extensionId) {
    const { notificationPage } = await this.beforeMessageSignature(extensionId);
    await signSimpleMessage.reject(notificationPage);
  }
  async confirmTransaction(extensionId, options) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await transaction.confirm(notificationPage, options?.gasSetting ?? "Average");
  }
  async rejectTransaction(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await transaction.reject(notificationPage);
  }
  async approveTokenPermission(extensionId, options) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await approvePermission.approve(notificationPage, options?.gasSetting ?? "Average");
  }
  async rejectTokenPermission(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await approvePermission.reject(notificationPage);
  }
  async closeUnsupportedNetworkWarning(extensionId) {
    const notificationPage = await getNotificationPageAndWaitForLoad(this.page.context(), extensionId);
    await closeUnsupportedNetworkWarning(notificationPage);
  }
};

// src/playwright/Phantom.ts
var NO_EXTENSION_ID_ERROR = new Error("Phantom extensionId is not set");
var Phantom = class extends PhantomAbstract {
  /**
   * Creates an instance of Phantom.
   *
   * @param context - The Playwright BrowserContext in which the Phantom extension is running.
   * @param page - The Playwright Page object representing the Phantom extension's main page.
   * @param password - The password for the Phantom wallet.
   * @param extensionId - The ID of the Phantom extension. Optional if no interaction with dapps is required.
   */
  constructor(context, page, password, extensionId) {
    super(password, extensionId);
    this.context = context;
    this.page = page;
    this.password = password;
    this.extensionId = extensionId;
    this.onboardingPage = new OnboardingPage(page);
    this.unlockPage = new UnlockPage(page);
    this.homePage = new HomePage(page);
    this.notificationPage = new NotificationPage(page);
  }
  /**
   * This property can be used to access selectors for the onboarding page.
   *
   * @public
   * @readonly
   */
  onboardingPage;
  /**
   * This property can be used to access selectors for the lock page.
   *
   * @public
   * @readonly
   */
  unlockPage;
  /**
   * This property can be used to access selectors for the home page.
   *
   * @public
   * @readonly
   */
  homePage;
  /**
   * This property can be used to access selectors for the notification page.
   *
   * @public
   * @readonly
   */
  notificationPage;
  /**
   * Imports a wallet using the given seed phrase.
   *
   * @param seedPhrase - The seed phrase to import.
   */
  async importWallet(seedPhrase) {
    await this.onboardingPage.importWallet(seedPhrase, this.password);
  }
  /**
   * Adds a new account with the given name.
   *
   * @param accountName - The name for the new account.
   */
  async addNewAccount(accountName) {
    await this.homePage.addNewAccount(accountName);
  }
  /**
   * Renames the currently selected account.
   *
   * @param currentAccountName - The current account name.
   * @param newAccountName - The new name for the account.
   */
  async renameAccount(currentAccountName, newAccountName) {
    await this.homePage.renameAccount(currentAccountName, newAccountName);
  }
  /**
   * Imports a wallet using the given private key.
   *
   * @param network - Network that the wallet belongs to.
   * @param privateKey - The private key to import.
   * @param privateKey - Name given to the new wallet/account.
   */
  async importWalletFromPrivateKey(network, privateKey, walletName) {
    await this.homePage.importWalletFromPrivateKey(network, privateKey, walletName);
  }
  /**
   * Switches to the account with the given name.
   *
   * @param accountName - The name of the account to switch to.
   */
  async switchAccount(accountName) {
    await this.homePage.switchAccount(accountName);
  }
  /**
   * Gets the address of the currently selected account.
   *
   * @param network - Network that the address belongs to.
   * @returns The account address.
   */
  async getAccountAddress(network) {
    return await this.homePage.getAccountAddress(network);
  }
  /**
   * Connects Phantom to a dapp.
   *
   * @param accounts - Optional array of account addresses to connect.
   * @throws {Error} If extensionId is not set.
   */
  async connectToDapp(account) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.connectToDapp(this.extensionId, account);
  }
  /**
   * Locks the Phantom wallet.
   */
  async lock() {
    await this.homePage.lock();
  }
  /**
   * Unlocks the Phantom wallet.
   */
  async unlock() {
    await this.unlockPage.unlock(this.password);
  }
  /**
   * Confirms a signature request.
   *
   * @throws {Error} If extensionId is not set.
   */
  async confirmSignature() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.signMessage(this.extensionId);
  }
  /**
   * Confirms a signature request with risk.
   *
   * @throws {Error} If extensionId is not set.
   */
  async confirmSignatureWithRisk() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.signMessageWithRisk(this.extensionId);
  }
  /**
   * Rejects a signature request.
   *
   * @throws {Error} If extensionId is not set.
   */
  async rejectSignature() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectMessage(this.extensionId);
  }
  /**
   * Confirms a transaction.
   *
   * @param options - Optional gas settings for the transaction.
   * @throws {Error} If extensionId is not set.
   */
  async confirmTransaction(options) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.confirmTransaction(this.extensionId, options);
  }
  /**
   * Rejects a transaction.
   *
   * @throws {Error} If extensionId is not set.
   */
  async rejectTransaction() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectTransaction(this.extensionId);
  }
  /**
   * Approves a token permission request.
   *
   * @param options - Optional settings for the approval.
   * @throws {Error} If extensionId is not set.
   */
  async approveTokenPermission(options) {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.approveTokenPermission(this.extensionId, options);
  }
  /**
   * Rejects a token permission request.
   *
   * @throws {Error} If extensionId is not set.
   */
  async rejectTokenPermission() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.rejectTokenPermission(this.extensionId);
  }
  /**
   * Navigates to the home page or wallet dashboard.
   */
  async goToHomePage() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.homePage.goToHomePage(this.extensionId);
  }
  /**
   * Navigates back to the home page.
   */
  async goBackToHomePage() {
    await this.homePage.goBackToHomePage();
  }
  /**
   * Opens the settings page.
   */
  async openSettings() {
    await this.homePage.openSettings();
  }
  /**
   * Toggles the display of test networks.
   */
  async toggleTestnetMode() {
    await this.homePage.toggleTestnetMode();
  }
  /**
   * Resets the account.
   */
  async resetApp() {
    await this.homePage.resetApp();
  }
  /**
   * Connects Phantom to a dapp.
   *
   * @param accounts - Optional array of account addresses to connect.
   * @throws {Error} If extensionId is not set.
   */
  async closeUnsupportedNetworkWarning() {
    if (!this.extensionId) {
      throw NO_EXTENSION_ID_ERROR;
    }
    await this.notificationPage.closeUnsupportedNetworkWarning(this.extensionId);
  }
};
var PHANTOM_EXTENSION_DOWNLOAD_URL = "https://crx-backup.phantom.dev/latest.crx";
async function prepareExtensionPhantom(forceCache = true) {
  let outputDir = "";
  if (forceCache) {
    outputDir = ensureCacheDirExists();
  } else {
    outputDir = process.platform === "win32" ? `file:\\\\\\${outputDir}` : path.resolve("./", "downloads");
    if (!await fs.exists(outputDir)) {
      fs.mkdirSync(outputDir);
    }
  }
  const downloadResult = await downloadFile({
    url: PHANTOM_EXTENSION_DOWNLOAD_URL,
    outputDir,
    fileName: "phantom-chrome-latest.crx"
  });
  const unzipResult = await unzipArchivePhantom({
    archivePath: downloadResult.filePath
  });
  return unzipResult.outputPath;
}
async function unlockForFixturePhantom(page, password) {
  const phantom = new Phantom(page.context(), page, password);
  await unlockWalletButReloadIfSpinnerDoesNotVanish(phantom);
}
async function unlockWalletButReloadIfSpinnerDoesNotVanish(phantom) {
  try {
    await phantom.unlock();
  } catch (e) {
    if (e instanceof errors.TimeoutError) {
      console.warn("[UnlockWalletButReloadIfSpinnerDoesNotVanish] Unlocking Phantom timed out. Reloading page...");
      const page = phantom.page;
      await page.reload();
      await waitForSpinnerToVanish(page);
    } else {
      throw e;
    }
  }
}
var Extension = z.object({
  id: z.string(),
  name: z.string()
});
var Extensions = z.array(Extension);
async function getExtensionIdPhantom(context, extensionName) {
  const page = await context.newPage();
  await page.goto("chrome://extensions");
  const unparsedExtensions = await page.evaluate("chrome.management.getAll()");
  const allExtensions = Extensions.parse(unparsedExtensions);
  const targetExtension = allExtensions.find(
    (extension) => extension.name.toLowerCase() === extensionName.toLowerCase()
  );
  if (!targetExtension) {
    throw new Error(
      [
        `[GetExtensionId] Extension with name ${extensionName} not found.`,
        `Available extensions: ${allExtensions.map((extension) => extension.name).join(", ")}`
      ].join("\n")
    );
  }
  await page.close();
  return targetExtension.id;
}

// src/playwright/fixture-actions/persistLocalStorage.ts
async function persistLocalStorage(origins, context) {
  const newPage = await context.newPage();
  for (const { origin, localStorage } of origins) {
    const frame = newPage.mainFrame();
    await frame.goto(origin);
    await frame.evaluate((localStorageData) => {
      localStorageData.forEach(({ name, value }) => {
        window.localStorage.setItem(name, value);
      });
    }, localStorage);
  }
  await newPage.close();
}

// src/playwright/utils/waitForTestPageLoad.ts
async function waitForTestPageLoad(context) {
  const testPageUrl = "about:blank";
  const isTestPage = (page) => page.url().includes(testPageUrl);
  let testPage = context.pages().find(isTestPage);
  if (!testPage) {
    testPage = await context.waitForEvent("page", {
      predicate: isTestPage,
      timeout: 1e4
    });
  }
  await waitUntilStable(testPage);
}

// src/playwright/utils/loadAndWaitForPopupPage.ts
async function loadAndWaitForPopupPage(context, extensionId) {
  let popupPage = context.pages()[0];
  await expect(async () => {
    popupPage = await context.newPage();
    await waitForTestPageLoad(context);
    await popupPage.goto(`chrome-extension://${extensionId}/popup.html`);
    await waitUntilStableBeforeUnlock(popupPage);
  }).toPass();
  return popupPage;
}

// src/playwright/fixtures/phantomFixtures.ts
var _phantomPage;
var phantomFixtures = (walletSetup, slowMo = 0) => {
  return test.extend({
    _contextPath: async ({ browserName }, use, testInfo) => {
      const contextPath = await createTempContextDir(browserName, testInfo.testId);
      await use(contextPath);
      const error = await removeTempContextDir(contextPath);
      if (error) {
        console.error(error);
      }
    },
    context: async ({ context: currentContext, _contextPath }, use) => {
      const cacheDirPath = path.join(process.cwd(), CACHE_DIR_NAME, walletSetup.hash);
      if (!await fs.exists(cacheDirPath)) {
        throw new Error(`Cache for ${walletSetup.hash} does not exist. Create it first!`);
      }
      await fs.copy(cacheDirPath, _contextPath);
      const phantomPath = await prepareExtensionPhantom();
      const browserArgs = [`--disable-extensions-except=${phantomPath}`];
      if (process.env.HEADLESS) {
        browserArgs.push("--headless=new");
        if (slowMo > 0) {
          console.warn("[WARNING] Slow motion makes no sense in headless mode. It will be ignored!");
        }
      }
      const context = await chromium.launchPersistentContext(_contextPath, {
        headless: false,
        args: browserArgs,
        slowMo: process.env.HEADLESS ? 0 : slowMo
      });
      const { cookies, origins } = await currentContext.storageState();
      if (cookies) {
        await context.addCookies(cookies);
      }
      if (origins && origins.length > 0) {
        await persistLocalStorage(origins, context);
      }
      const extensionId = await getExtensionIdPhantom(context, "Phantom");
      _phantomPage = await loadAndWaitForPopupPage(context, extensionId);
      await unlock(_phantomPage, walletSetup.walletPassword);
      await use(context);
      await context.close();
    },
    phantomPage: async ({ context: _ }, use) => {
      await closeSuiAndMonadIfPresent(_phantomPage);
      await use(_phantomPage);
    },
    extensionId: async ({ context }, use) => {
      const extensionId = await getExtensionIdPhantom(context, "Phantom");
      await use(extensionId);
    },
    phantom: async ({ context, extensionId }, use) => {
      const phantom = new Phantom(context, _phantomPage, walletSetup.walletPassword, extensionId);
      await use(phantom);
    },
    page: async ({ page }, use) => {
      await page.goto("/");
      await use(page);
    }
  });
};

export { Phantom, getExtensionIdPhantom, phantomFixtures, unlockForFixturePhantom };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map